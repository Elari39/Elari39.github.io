---
title: "Day 03: 数组篇总结"
date: 2026-02-21T13:00:00+08:00
draft: false
tags: ["算法", "数组", "总结", "Go"]
categories: ["代码随想录"]
---

# 数组篇总结

今天是**代码随想录**算法训练营的第三天，我们已经完成了数组篇的学习。数组作为最基础的数据结构，虽然看似简单，但其中蕴含的算法思想（如二分、双指针、滑动窗口）却是解决复杂问题的基石。

在这篇文章中，我们将对过去两天学习的**数组理论**、**经典算法**以及 **Go 语言实现细节**进行一次系统性的总结，帮助大家构建完整的知识体系。

---

## 一、数组理论基础回顾

### 1. 内存模型
*   **定义**：数组是存放在**连续内存空间**上的相同类型数据的集合。
*   **特性**：
    *   **随机访问**：可以通过下标直接访问元素，时间复杂度为 `O(1)`。
    *   **插入/删除**：由于需要移动后续元素以保持连续性，时间复杂度为 `O(n)`。
*   **注意**：在 C++ 中二维数组也是连续的，但在 Go (以及 Java) 中，二维数组（切片）是切片的切片，内存上不一定连续。

### 2. Go 语言中的数组与切片
*   **数组 (Array)**：固定长度，值类型。传递给函数时会发生拷贝。
*   **切片 (Slice)**：动态长度，引用类型（底层指向数组）。算法题中主要使用切片。
    *   **初始化**：`make([]int, len, cap)` 或 `[]int{}`。
    *   **底层原理**：包含指针、长度 (`len`) 和容量 (`cap`)。扩容时可能会发生内存重新分配和拷贝。

---

## 二、四大经典解题套路

我们在 `704. 二分查找`、`27. 移除元素`、`977. 有序数组的平方`、`209. 长度最小的子数组` 和 `59. 螺旋矩阵 II` 中重点练习了以下四种方法：

### 1. 二分查找 (Binary Search)
*   **适用场景**：**有序**数组、无重复元素（通常）。
*   **核心思想**：每次比较将查找范围缩小一半。
*   **关键点**：**循环不变量**（Loop Invariant）。
    *   **左闭右闭** `[left, right]`：
        *   初始化：`right = len(nums) - 1`
        *   循环条件：`left <= right`
        *   更新：`right = mid - 1`
    *   **左闭右开** `[left, right)`：
        *   初始化：`right = len(nums)`
        *   循环条件：`left < right`
        *   更新：`right = mid`
*   **Go 实现细节**：
    ```go
    mid := left + (right-left)>>1 // 防止溢出，位运算更高效
    ```

### 2. 双指针法 (Two Pointers)
*   **核心思想**：通过两个指针在一个 `for` 循环下完成两个 `for` 循环的工作，将 `O(n²)` 优化为 `O(n)`。
*   **常见形式**：
    *   **快慢指针**（`27. 移除元素`）：
        *   `fast` 指针：寻找新数组的元素（不包含目标值的元素）。
        *   `slow` 指针：指向新数组更新的位置。
        *   **原地修改**，空间复杂度 `O(1)`。
    *   **左右指针**（`977. 有序数组的平方`）：
        *   利用数组**有序**（或部分有序）的特性，从两端向中间遍历。
        *   解决负数平方后变大的问题，从两头向中间填充结果数组。

### 3. 滑动窗口 (Sliding Window)
*   **适用场景**：寻找满足特定条件的**连续**子数组（如最小长度、最大和）。
*   **核心思想**：
    *   **本质**：也是双指针的一种，但侧重于维护一个“窗口”。
    *   **操作**：`right` 主动向右扩展窗口，当窗口满足条件时，`left` 被动向右收缩窗口。
*   **关键点**：
    *   窗口内是什么？
    *   什么条件下移动起始位置（收缩窗口）？
    *   移动起始位置时，窗口内数据如何更新？
*   **复杂度**：每个元素最多进窗口一次、出窗口一次，时间复杂度 `O(n)`。

### 4. 模拟 (Simulation)
*   **适用场景**：逻辑复杂、边界条件多的题目（如 `59. 螺旋矩阵 II`）。
*   **核心思想**：不涉及复杂算法，而是单纯模拟过程。
*   **关键点**：**循环不变量**。
    *   例如画圈，必须坚持统一的原则（如“左闭右开”），每条边处理规则要一致，避免混乱。
    *   边界处理要仔细（奇数中间点、拐角处）。

---

## 三、Go 语言刷题小贴士

1.  **切片越界**：Go 对切片越界检查很严格，运行时会 panic，务必注意边界条件（如 `right < len(nums)`）。
2.  **变量声明**：使用 `:=` 简短声明非常方便，但要注意不要在 `if/for` 块内意外遮蔽（shadow）外部变量。
3.  **内置函数**：
    *   `sort.Ints(nums)`：快速排序。
    *   `math.Max`, `math.Min`：注意它们接收 `float64`，处理 `int` 时通常自己写辅助函数更方便（或强转）。
    *   Go 标准库没有直接的 `abs` (int)，建议手写简单的 `abs` 函数。

---

## 四、总结

数组篇的结束通过几道经典题目，让我们掌握了**操作索引**的核心能力。无论是二分法的区间控制，还是双指针的精妙移动，亦或是滑动窗口的动态伸缩，本质上都是在**高效地利用数组的连续性**。

接下来的**链表篇**，我们将面对完全不同的内存结构（非连续），指针的操作将更加纯粹和抽象。大家加油！

> **Talk is cheap. Show me the code.**
