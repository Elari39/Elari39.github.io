<!doctype html><html lang=zh-cn data-theme-mode=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>GoCache 学习建议 | Elari39</title><meta name=description content="请别在意。
我是旅人，得继续旅行才行…
"><script>window.siteConfig=JSON.parse('{"anchor_icon":null,"base":"https://Elari39.github.io/","clipboard":{"copyright":{"count":50,"enable":false,"license_type":"by-nc-sa"},"fail":{"en":"Copy failed (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-br":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ","zh-cn":"复制失败 (ﾟ⊿ﾟ)ﾂ","zh-tw":"複製失敗 (ﾟ⊿ﾟ)ﾂ"},"success":{"en":"Copy successfully (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-br":"Copiado com sucesso (*^▽^*)","zh-cn":"复制成功 (*^▽^*)","zh-tw":"複製成功 (*^▽^*)"}},"code_block":{"expand":true},"icon_font":"4552607_4k4bc36ef96","outdate":{"daysago":180,"enable":false,"message":{"en":"This article was last updated on {time}. Please note that the content may no longer be applicable.","ja":"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。","pt-br":"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.","zh-cn":"本文最后更新于 {time}，请注意文中内容可能已不适用。","zh-tw":"本文最後更新於 {time}，請注意文中內容可能已不適用。"}}}')</script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap" media=print onload='this.media="all"'><link rel=preload href=//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=stylesheet href=/css/loader.min.ac746e154f756f8220326eeb52a719f142ab038be5a8ddf30ea5ef15ef2356ea.css><meta property="og:type" content="website"><meta property="og:title" content="GoCache 学习建议 | Elari39"><meta property="og:description" content="请别在意。
我是旅人，得继续旅行才行…
"><meta property="og:url" content="https://Elari39.github.io/post/gocache/"><meta property="og:site_name" content="Elari的博客"><meta property="og:image" content="/post/gocache/gocache.jpg"><meta property="article:author" content="Elari39"><meta property="article:published_time" content="2026-02-14T11:00:00+08:00"><meta property="article:modified_time" content="2026-02-14T11:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:image content="/post/gocache/gocache.jpg"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.d356b9fcdcb0a64f094049c52fdb5d1cf4326130f6ff2847fce56c677e820ff0.css><link rel=preload as=style href=https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css integrity=sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx/1oA/0l8ysE crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css integrity=sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz+YI crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><script src=https://npm.webcache.cn/pace-js@1.2.4/pace.min.js integrity=sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8 crossorigin=anonymous></script><link rel=stylesheet href=https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css integrity=sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa crossorigin=anonymous></head><body><div id=loader><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class=spinner-box><div class="loading-taichi rotate"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" shape-rendering="geometricPrecision"><path d="M303.5 432a80 80 0 01-12 160 80 80 0 0112-160z" fill="var(--red-1, #ff5252)"/><path d="M512 65a447 447 0 010 894V929a417 417 0 000-834 417 417 0 000 834v30a447 447 0 010-894zm0 30A417 417 0 01929 512 208.5 208.5.0 01720.5 720.5V592a80 80 0 000-160 80 80 0 000 160V720.5A208.5 208.5.0 01512 512 208.5 208.5.0 00303.5 303.5 208.5 208.5.0 0095 512 417 417 0 01512 95z" fill="var(--red-1, #ff5252)"/></svg></div><div class=loading-word>少女祈祷中...</div></div></div></div><script>var time=null,loaderEl=document.getElementById("loader"),startLoading=()=>{time=Date.now(),loaderEl.classList.remove("loading")},hideLoader=()=>{document.body.style.overflow="auto",loader.classList.add("loading")},endLoading=()=>{time?Date.now()-time>500?(time=null,hideLoader()):(setTimeout(endLoading,500-(Date.now()-time)),time=null):hideLoader()};window.addEventListener("DOMContentLoaded",endLoading),loaderEl.addEventListener("click",endLoading)</script><div id=copy-tooltip></div><div id=lang-tooltip>本文章没有找到对应的语言版本</div><div id=heatmap-tooltip></div><div id=container><div id=wrap><div id=header-nav><nav id=main-nav aria-label="Primary navigation"><a class=main-nav-link-wrap href=/><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>首页</span>
</a><a class=main-nav-link-wrap href=/archives><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>归档</span>
</a><a class=main-nav-link-wrap href=/about><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>关于</span>
</a><a id=main-nav-toggle class=nav-icon aria-label="Toggle navigation" role=button></a></nav><nav id=sub-nav aria-label="Secondary navigation"></nav></div><header id=header aria-label="Site header"><picture></picture>
<img fetchpriority=high src=/post/gocache/gocache.jpg alt="GoCache 学习建议"><div id=header-outer><div id=header-title><span id=logo><h1 data-aos=slide-up>GoCache 学习建议</h1></span><h2 id=subtitle-wrap data-aos=slide-down></h2></div></div></header><div id=content aria-label="Page content" class=sidebar-right><aside id=sidebar aria-label=Sidebar><div class="sidebar-wrapper-container sticky"><div class=sidebar-wrapper><div class=sidebar-wrap data-aos=fade-up><div class=sidebar-toc-sidebar style=margin-bottom:10px><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><a href=#基础要求>基础要求</a></li><li><a href=#循序渐进的学习顺序>循序渐进的学习顺序</a></li><li><a href=#代码阅读方式>代码阅读方式</a></li></ul><ul><li><a href=#什么是缓存>什么是缓存</a></li><li><a href=#为什么要实现缓存系统>为什么要实现缓存系统</a></li><li><a href=#在什么地方加缓存>在什么地方加缓存</a></li><li><a href=#本地缓存local-cache>本地缓存（Local Cache）</a><ul><li><a href=#优势>优势</a></li><li><a href=#劣势>劣势</a></li><li><a href=#本地缓存的适用场景>本地缓存的适用场景</a></li></ul></li><li><a href=#分布式缓存distributed-cache>分布式缓存（Distributed Cache）</a><ul><li><a href=#优势-1>优势</a></li><li><a href=#劣势-1>劣势</a></li><li><a href=#分布式缓存的适用场景>分布式缓存的适用场景</a></li></ul></li><li><a href=#多级缓存two-level-cache>多级缓存（Two-Level Cache）</a><ul><li><a href=#多级缓存的工作流程>多级缓存的工作流程</a></li><li><a href=#多级缓存一致性挑战>多级缓存一致性挑战</a></li></ul></li><li><a href=#做完本项目你的收获>做完本项目你的收获</a></li></ul><ul><li><a href=#整体架构>整体架构</a></li><li><a href=#核心组件及其关系>核心组件及其关系</a><ul><li><a href=#数据存储层>数据存储层</a></li><li><a href=#缓存核心层>缓存核心层</a></li><li><a href=#分布式协调层>分布式协调层</a></li><li><a href=#网络通信层>网络通信层</a></li></ul></li><li><a href=#设计模式与最佳实践>设计模式与最佳实践</a><ul><li><a href=#使用的设计模式>使用的设计模式</a></li><li><a href=#性能优化技巧>性能优化技巧</a></li><li><a href=#扩展性设计>扩展性设计</a></li></ul></li></ul><ul><li><a href=#1-安装>1. 安装</a></li><li><a href=#2-启动-etcd>2. 启动 etcd</a></li><li><a href=#3-运行示例>3. 运行示例</a><ul><li><a href=#4-多节点部署>4. 多节点部署</a></li></ul></li></ul><ul><li><a href=#核心结构设计>核心结构设计</a><ul><li><a href=#全局缓存组管理>全局缓存组管理</a></li><li><a href=#数据加载接口>数据加载接口</a></li><li><a href=#缓存组结构>缓存组结构</a></li></ul></li><li><a href=#核心功能实现>核心功能实现</a><ul><li><a href=#数据获取>数据获取</a></li><li><a href=#数据加载>数据加载</a></li><li><a href=#数据设置>数据设置</a></li><li><a href=#分布式操作同步>分布式操作同步</a></li></ul></li><li><a href=#功能特定分析>功能特定分析</a><ul><li><a href=#多级缓存架构>多级缓存架构</a></li><li><a href=#防止击穿>防止击穿</a></li></ul></li></ul><ul><li><a href=#最近最少使用lru>最近最少使用（LRU）</a><ul><li><a href=#算法原理>算法原理</a></li><li><a href=#实现方式>实现方式</a></li><li><a href=#优缺点>优缺点</a></li><li><a href=#kamacache-的实现>KamaCache 的实现</a></li></ul></li><li><a href=#lru-kleast-recently-used-k>LRU-K（Least Recently Used K）</a><ul><li><a href=#算法原理-1>算法原理</a></li><li><a href=#实现方式-1>实现方式</a></li><li><a href=#优缺点-1>优缺点</a></li></ul></li><li><a href=#lru-2least-recently-used-2>LRU-2（Least Recently Used 2）</a><ul><li><a href=#算法原理-2>算法原理</a></li><li><a href=#实现方式-2>实现方式</a></li><li><a href=#优缺点-2>优缺点</a></li><li><a href=#kamacache-的实现-1>KamaCache 的实现</a></li></ul></li><li><a href=#最少使用频率lfu>最少使用频率（LFU）</a><ul><li><a href=#算法原理-3>算法原理</a></li><li><a href=#实现方式-3>实现方式</a></li><li><a href=#优缺点-3>优缺点</a></li></ul></li></ul><ul><li><a href=#缓存击穿cache-breakdown>缓存击穿（Cache Breakdown）</a></li><li><a href=#缓存雪崩cache-avalanche>缓存雪崩（Cache Avalanche）</a></li><li><a href=#缓存穿透cache-penetration>缓存穿透（Cache Penetration）</a></li><li><a href=#singleflight-1>SingleFlight</a><ul><li><a href=#核心数据结构>核心数据结构</a></li><li><a href=#实现>实现</a></li></ul></li></ul><ul><li><a href=#为什么需要一致性哈希>为什么需要一致性哈希？</a><ul><li><a href=#节点数量变化了怎么办>节点数量变化了怎么办？</a></li><li><a href=#算法原理-4>算法原理</a></li><li><a href=#步骤>步骤</a></li><li><a href=#数据倾斜问题>数据倾斜问题</a></li></ul></li><li><a href=#kamacache-实现>KamaCache 实现</a><ul><li></li></ul></li><li><a href=#一致性哈希是分布式算法吗>一致性哈希是分布式算法吗？</a><ul><li><a href=#与-redis-的不同之处>与 Redis 的不同之处</a></li><li><a href=#适用于哪些场景>适用于哪些场景？</a></li></ul></li></ul><ul><li><a href=#服务端模块>服务端模块</a><ul><li><a href=#核心结构设计-1>核心结构设计</a></li><li><a href=#服务创建和生命周期管理>服务创建和生命周期管理</a></li><li><a href=#缓存操作接口>缓存操作接口</a></li></ul></li><li><a href=#节点选择器>节点选择器</a><ul><li><a href=#核心接口设计>核心接口设计</a></li><li><a href=#服务发现与节点管理>服务发现与节点管理</a></li><li><a href=#一致性哈希与节点选择>一致性哈希与节点选择</a></li></ul></li></ul><ul><li><a href=#项目分布式缓存系统-lcache>项目：分布式缓存系统 LCache</a></li></ul><ul><li><ul><li></li></ul></li></ul></nav></div></div></div></div><div class=sidebar-widget></div></div></aside><section id=main aria-label="Main content"><article class="h-entry article" itemscope itemtype=https://schema.org/BlogPosting><div class=article-inner data-aos=fade-up><div class=article-meta><div class=article-date><span class="article-date-link icon-calendar" data-aos=zoom-in><time datetime="2026-02-14 11:00:00 +0800 +0800" itemprop=datePublished>2026-02-14</time>
<time style=display:none id=post-update-time>2026-02-14</time></span></div></div><div class=hr-line></div><div class="e-content article-entry" itemprop=articleBody><h1 id=学习建议><a class=header-anchor href=#%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae></a>学习建议</h1><p><strong>完成项目指导时间</strong></p><ul><li>如果具备【基础要求】里的基础，每天 6 小时，约 7 天完成。</li><li>如果边学边做，每天 6~8 小时，约 15 天完成。</li></ul><p><strong>代码量</strong><br>2000 行左右（除去测试代码）</p><hr><h2 id=基础要求><a class=header-anchor href=#%e5%9f%ba%e7%a1%80%e8%a6%81%e6%b1%82></a>基础要求</h2><ul><li><strong>Go 语言基础</strong>：goroutine、channel、接口等核心概念</li><li><strong>缓存原理</strong>：缓存淘汰策略（LRU、LFU 等）</li><li><strong>网络编程</strong>：gRPC 基础、HTTP 协议、TCP/IP</li></ul><hr><h2 id=循序渐进的学习顺序><a class=header-anchor href=#%e5%be%aa%e5%ba%8f%e6%b8%90%e8%bf%9b%e7%9a%84%e5%ad%a6%e4%b9%a0%e9%a1%ba%e5%ba%8f></a>循序渐进的学习顺序</h2><ol><li><p><strong>从单机缓存开始</strong></p><ul><li>先理解 <code>ByteView</code>、<code>lruCache</code> 等核心数据结构</li><li>熟悉 <code>Cache</code> 和基本的缓存操作</li></ul></li><li><p><strong>理解分组缓存</strong></p><ul><li>学习 <code>Group</code> 结构及其工作原理</li><li>掌握缓存加载、过期策略等机制</li></ul></li><li><p><strong>研究分布式扩展</strong></p><ul><li>一致性哈希算法实现</li><li>节点间通信协议</li><li>服务注册与发现</li></ul></li><li><p><strong>深入高级特性</strong></p><ul><li>缓存击穿防护</li><li>分段锁与高并发优化</li><li>优雅关闭与资源管理</li></ul></li></ol><hr><h2 id=代码阅读方式><a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e9%98%85%e8%af%bb%e6%96%b9%e5%bc%8f></a>代码阅读方式</h2><ol><li><p><strong>绘制组件关系图</strong></p><ul><li>梳理核心接口和实现类</li><li>理清组件间的调用关系</li></ul></li><li><p><strong>断点调试关键流程</strong></p><ul><li><code>Set/Get</code> 操作的完整链路</li><li>分布式场景下的数据同步</li></ul></li><li><p><strong>编写单元测试</strong></p><ul><li>为关键组件编写测试用例</li><li>使用基准测试验证性能优化</li></ul></li><li><p><strong>模拟故障场景</strong></p><ul><li>节点宕机时的系统行为</li><li>网络分区下的一致性保证</li></ul></li></ol><hr><h1 id=开篇><a class=header-anchor href=#%e5%bc%80%e7%af%87></a>开篇</h1><p>帮助初次学习缓存项目的人能够更快的上手项目的开发<br>项目名称：<strong>Cache</strong><br>项目地址：<a href=https://github.com/youngyangyang04/KamaCache-Go>缓存系统（Go）</a></p><hr><h2 id=什么是缓存><a class=header-anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98></a>什么是缓存</h2><p>缓存是将高频访问的数据暂存到内存中，是加速数据访问的存储，降低延迟，提高吞吐率的利器。</p><h2 id=为什么要实现缓存系统><a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%bc%93%e5%ad%98%e7%b3%bb%e7%bb%9f></a>为什么要实现缓存系统</h2><p>因缓存的使用相关需求，通过牺牲一部分服务器内存，减少对磁盘或者数据库资源进行直接读写，可换取更快响应速度，尤其是处理高并发的场景，负责存储经常访问的数据，通过设计合理的缓存机制提高资源的访问效率。由于服务器的内存是有限的，我们不能把所有数据都存放在内存中，因此需要一种机制来决定当使用内存超过一定标准时，应该删除哪些数据，这就涉及到缓存淘汰策略的选择。</p><hr><h2 id=在什么地方加缓存><a class=header-anchor href=#%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%b0%e6%96%b9%e5%8a%a0%e7%bc%93%e5%ad%98></a>在什么地方加缓存</h2><blockquote><p>参考文章：<a href=https://blog.csdn.net/chongfa2008/article/details/121956961>https://blog.csdn.net/chongfa2008/article/details/121956961</a></p></blockquote><p>缓存对于每个开发者来说是相当熟悉了，为了提高程序的性能我们会去加缓存，但是在什么地方加缓存，如何加缓存呢？</p><p>举个例子：假设一个网站需要提高性能，缓存可以放在浏览器、反向代理服务器、应用程序进程内，还可以放在分布式缓存系统中。</p><p><img src=cache-location.png alt=缓存位置示意图></p><p>从用户请求数据到数据返回，数据经过了浏览器、CDN、代理服务器、应用服务器以及数据库各个环节。每个环节都可以运用缓存技术。从浏览器/客户端开始请求数据，通过 HTTP 配合 CDN 获取数据的变更情况，到达代理服务器（Nginx）可以通过反向代理获取静态资源。再往下来到应用服务器可以通过进程内（堆内）缓存、分布式缓存等方式获取数据。如果以上所有缓存都没有命中数据，才会回源到数据库。</p><p><strong>缓存的顺序</strong>：<br>用户请求 → HTTP 缓存 → CDN 缓存 → 代理服务器缓存 → 进程内缓存 → 分布式缓存 → 数据库</p><p>距离用户越近，缓存能够发挥的效果越好。而根据缓存的存储方式和应用的耦合度，缓存可以分为<strong>本地缓存</strong>（Local Cache）和<strong>分布式缓存</strong>（Distributed Cache）。本地缓存更注重访问速度，而分布式缓存则关注数据一致性和扩展性。</p><hr><h2 id=本地缓存local-cache><a class=header-anchor href=#%e6%9c%ac%e5%9c%b0%e7%bc%93%e5%ad%98local-cache></a>本地缓存（Local Cache）</h2><p>本地缓存是直接存储在应用进程内存中的缓存，应用程序与缓存共存于同一进程，无需网络通信即可访问数据，访问速度极快。</p><h3 id=优势><a class=header-anchor href=#%e4%bc%98%e5%8a%bf></a>优势</h3><ol><li><strong>访问速度极快</strong>：数据存储在应用进程内存，避免了网络延迟，读取性能远超分布式缓存。</li><li><strong>无额外性能开销</strong>：直接在进程内操作内存，无需远程调用，不消耗额外的网络带宽和计算资源。</li><li><strong>适用于高频小数据缓存</strong>：对于高频访问、较小体积的数据（如配置参数、Token、用户会话信息），本地缓存是最佳选择。</li></ol><h3 id=劣势><a class=header-anchor href=#%e5%8a%a3%e5%8a%bf></a>劣势</h3><ol><li><p><strong>数据一致性问题</strong></p><ul><li>由于缓存数据存储在应用本地，不同服务器之间的缓存内容可能不一致。</li><li>例如：用户第一次请求命中服务器 A，有缓存；第二次命中服务器 B，没有缓存，导致重复查询数据库。</li><li><strong>解决方案</strong>：<ul><li>基于 Redis 的发布/订阅（Pub/Sub）机制进行缓存变更通知，实现跨节点数据同步。</li><li>使用消息队列（Kafka/RabbitMQ）实现异步数据同步，确保所有应用节点缓存数据一致。</li></ul></li></ul></li><li><p><strong>缓存容量受限</strong></p><ul><li>由于缓存存储在应用进程的内存空间，其大小受 JVM（Java）/进程内存（Go、Python）限制，无法存储大规模数据。</li><li><strong>解决方案</strong>：<ul><li>使用 LRU 策略，自动淘汰不常访问的数据。</li><li>采用“本地+分布式”结合的两级缓存机制，本地缓存仅存储热点数据。</li></ul></li></ul></li><li><p><strong>应用进程重启，缓存丢失</strong></p><ul><li>本地缓存存储在应用进程内存中，当应用重启时，缓存数据会丢失，需要重新加载。</li><li><strong>解决方案</strong>：<ul><li>使用持久化存储（如 Redis AOF/RDB 持久化，或者数据库存储）。</li><li>应用启动时自动预热缓存（从数据库或 Redis 预加载热点数据到本地缓存）。</li></ul></li></ul></li></ol><h3 id=本地缓存的适用场景><a class=header-anchor href=#%e6%9c%ac%e5%9c%b0%e7%bc%93%e5%ad%98%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af></a>本地缓存的适用场景</h3><ul><li>只在单个应用实例内部访问的缓存（如进程级别的数据缓存）。</li><li>高频小数据（如配置信息、短期计算结果、用户会话信息）。</li><li>对数据一致性要求不高，或可通过同步机制（如 Pub/Sub）解决一致性问题。</li></ul><hr><h2 id=分布式缓存distributed-cache><a class=header-anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98distributed-cache></a>分布式缓存（Distributed Cache）</h2><p>分布式缓存是一种独立部署的缓存服务，与应用进程分离，多个应用实例共享同一份缓存数据，典型实现包括 Redis、Memcached、etcd。</p><h3 id=优势-1><a class=header-anchor href=#%e4%bc%98%e5%8a%bf-1></a>优势</h3><ol><li><p><strong>支持大规模存储</strong></p><ul><li>缓存数据分布在多个服务器上，不受单机内存限制，可扩展存储空间。</li><li>例如：Redis Cluster 支持横向扩展，通过分片技术存储 TB 级数据。</li></ul></li><li><p><strong>数据一致性更高</strong></p><ul><li>所有应用节点共享同一份缓存数据，不同服务器间的缓存一致性更容易保证。</li><li>例如：所有服务器都访问 Redis，数据变更时只需更新 Redis 即可同步到所有应用实例。</li></ul></li><li><p><strong>高可用性</strong></p><ul><li>Redis Sentinel 或主从复制方案可提供缓存高可用性，即使某个缓存节点宕机，仍可快速切换到备用节点，避免单点故障。</li><li>持久化机制（AOF/RDB）使 Redis 在服务器重启后仍能恢复数据，保证缓存数据不会丢失。</li></ul></li><li><p><strong>适用于分布式系统</strong></p><ul><li>现代应用通常采用多实例部署（如 Kubernetes 微服务架构），本地缓存难以满足数据共享需求，而分布式缓存天然适用于多实例环境。</li></ul></li></ol><h3 id=劣势-1><a class=header-anchor href=#%e5%8a%a3%e5%8a%bf-1></a>劣势</h3><ol><li><p><strong>访问速度比本地缓存慢</strong></p><ul><li>由于数据需要网络传输，访问延迟比本地缓存高 1~2 个数量级（本地缓存纳秒级，Redis 微秒级）。</li><li><strong>解决方案</strong>：<ul><li>使用连接池，减少 TCP 连接开销。</li><li>启用 Redis Pipeline，批量处理请求，减少 RTT（Round Trip Time）。</li></ul></li></ul></li><li><p><strong>运维成本高</strong></p><ul><li>需要部署、管理 Redis/Memcached 集群，涉及节点扩展、故障切换、性能优化。</li><li><strong>解决方案</strong>：<ul><li>使用 Redis Cloud（云托管），降低运维成本。</li><li>采用 Kubernetes Operator，自动管理 Redis 集群。</li></ul></li></ul></li><li><p><strong>可能存在数据同步延迟</strong></p><ul><li>在主从复制模式下，主节点的数据同步到从节点存在网络和 CPU 延迟，导致短时间内数据可能不一致。</li><li><strong>解决方案</strong>：<ul><li>开启强一致性模式（<code>WAIT</code> 命令），保证写操作完成后再返回成功。</li><li>使用分布式事务（如 Redlock 算法），提高一致性。</li></ul></li></ul></li></ol><h3 id=分布式缓存的适用场景><a class=header-anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af></a>分布式缓存的适用场景</h3><ul><li>多实例应用共享缓存（如微服务架构）。</li><li>大规模数据缓存（如海量用户会话、热点文章缓存）。</li><li>高可用场景（如 Redis 作为数据库前置缓存，减少数据库压力）。</li></ul><hr><h2 id=多级缓存two-level-cache><a class=header-anchor href=#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98two-level-cache></a>多级缓存（Two-Level Cache）</h2><p>为了兼顾本地缓存的高性能和分布式缓存的数据一致性，可以采用<strong>多级缓存</strong>设计：</p><ul><li><strong>本地缓存（一级缓存）</strong>：存储热点数据，避免高频访问 Redis，提升访问速度。</li><li><strong>分布式缓存（二级缓存）</strong>：作为主缓存存储，确保数据一致性和可扩展性。</li></ul><h3 id=多级缓存的工作流程><a class=header-anchor href=#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b></a>多级缓存的工作流程</h3><ol><li><p><strong>查询本地缓存</strong></p><ul><li>若命中，直接返回数据（最快）。</li><li>若未命中，继续查询分布式缓存。</li></ul></li><li><p><strong>查询分布式缓存</strong></p><ul><li>若命中，更新本地缓存，并返回数据。</li><li>若仍未命中，查询数据库。</li></ul></li><li><p><strong>查询数据库</strong></p><ul><li>从数据库获取数据后，更新分布式缓存，同时更新本地缓存，返回数据。</li></ul></li></ol><h3 id=多级缓存一致性挑战><a class=header-anchor href=#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e6%8c%91%e6%88%98></a>多级缓存一致性挑战</h3><ul><li>需要保证本地缓存和分布式缓存的一致性：<ul><li><strong>主动失效策略</strong>：数据变更时清除所有缓存。</li><li><strong>异步消息同步</strong>：如 Kafka/Redis Pub/Sub 实现变更通知。</li><li><strong>TTL 机制</strong>：本地缓存设置短 TTL，确保数据不长期失效。</li></ul></li></ul><hr><h2 id=做完本项目你的收获><a class=header-anchor href=#%e5%81%9a%e5%ae%8c%e6%9c%ac%e9%a1%b9%e7%9b%ae%e4%bd%a0%e7%9a%84%e6%94%b6%e8%8e%b7></a>做完本项目你的收获</h2><ul><li><p><strong>Go 语言能力</strong></p><ul><li>掌握 goroutine、channel 等并发编程模型</li><li>理解分段锁、原子操作、无锁优化的工程实践</li><li>熟悉 gRPC 通信、etcd 服务发现、SingleFlight 请求合并</li></ul></li><li><p><strong>缓存核心机制</strong></p><ul><li>实现多种淘汰策略（LRU、LFU、ARC），理解各自优缺点</li><li>设计两级缓存（本地 + 分布式），兼顾速度与一致性</li><li>应对缓存穿透、击穿、雪崩三大问题</li></ul></li><li><p><strong>分布式系统实践</strong></p><ul><li>Raft/一致性哈希保证节点数据分布均衡</li><li>etcd 支撑动态节点管理与健康检查</li><li>高并发下的热点 key 防护与缓存预热</li></ul></li><li><p><strong>工程化与性能优化</strong></p><ul><li>细粒度锁 + 内存预分配，减少 GC 压力</li><li>日志监控与优雅关闭，确保系统可观测性与稳定性</li><li>命中率、吞吐量、延迟等指标驱动的性能调优</li></ul></li></ul><hr><h1 id=2-项目背景介绍><a class=header-anchor href=#2-%e9%a1%b9%e7%9b%ae%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d></a>2. 项目背景介绍</h1><p>KamaCache 是一个分布式缓存，但也可以直接当作本地缓存使用。它借鉴了开源项目 <code>groupcache</code> 的实现思路，在此基础上做了拓展优化：</p><ol><li>将单独 LRU 算法改成多种算法插件式选择</li><li>将 HTTP 通信改为 RPC 通信，提高网络通信效率</li><li>细化锁的粒度来提高并发性能</li><li>实现热点互备来避免 hot key 频繁请求网络影响性能</li><li>加入 etcd 进行分布式节点的监测，实现节点的动态管理</li><li>加入缓存过期机制，自动清理超时缓存</li></ol><hr><h2 id=整体架构><a class=header-anchor href=#%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84></a>整体架构</h2><pre tabindex=0><code>┌────────────┐    ┌────────────┐    ┌────────────┐
│  Client    │    │  Client    │    │  Client    │
└─────┬──────┘    └─────┬──────┘    └─────┬──────┘
      │                 │                 │
      │    请求分发     │                 │
      ▼                 ▼                 ▼
┌────────────┐    ┌────────────┐    ┌────────────┐
│ LCache节点 │◄──►│ LCache节点 │◄──►│ LCache节点 │
└─────┬──────┘    └─────┬──────┘    └─────┬──────┘
      │                 │                 │
      └────────┬────────┘────────┬───────┘
               │                 │
               ▼                 ▼
        ┌──────────────┐  ┌─────────────┐
        │  数据源/DB   │  │    etcd     │
        └──────────────┘  └─────────────┘
</code></pre><ul><li><strong>Client</strong>：通过 gRPC 与缓存节点通信的客户端</li><li><strong>LCache节点</strong>：缓存服务节点，负责存储和管理缓存数据</li><li><strong>etcd</strong>：用于服务注册发现和节点协调</li><li><strong>数据源/DB</strong>：当缓存未命中时的数据来源</li></ul><hr><h2 id=核心组件及其关系><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%85%b3%e7%b3%bb></a>核心组件及其关系</h2><pre tabindex=0><code>┌─────────────────────────────────────────────────────────────────┐
│                         Client Application                      │
└───────────────┬─────────────────────────────────┬───────────────┘
                │                                 │
                ▼                                 ▼
┌───────────────────────────────┐   ┌───────────────────────────────┐
│         Local Cache           │   │      Distributed Cache        │
│                               │   │                               │
│  ┌───────────────────────┐    │   │  ┌───────────────────────┐    │
│  │                       │    │   │  │                       │    │
│  │        Group          │◄───┼───┼──┤      ClientPicker     │    │
│  │  - name               │    │   │  │  - selfAddr           │    │
│  │  - getter             │    │   │  │  - svcName            │    │
│  │  - mainCache          │◄───┼───┼──┤  - consistentHash     │    │
│  │  - peers              │    │   │  │  - clients            │    │
│  │  - loader             │    │   │  │                       │    │
│  │  - expiration         │    │   │  └───────────┬───────────┘    │
│  │                       │    │   │              │                 │
│  └───────────┬───────────┘    │   │              │                 │
│              │                │   │              ▼                 │
│              ▼                │   │  ┌───────────────────────┐    │
│  ┌───────────────────────┐    │   │  │                       │    │
│  │                       │    │   │  │        Client         │    │
│  │        Cache          │    │   │  │  - addr               │    │
│  │  - store              │    │   │  │  - client             │    │
│  │  - opts               │    │   │  │                       │    │
│  │  - hits/misses        │    │   │  └───────────────────────┘    │
│  │                       │    │   │                               │
│  └───────────┬───────────┘    │   └───────────────────────────────┘
│              │                │
│              ▼                │                    ┌───────────────┐
│  ┌───────────────────────┐    │                    │               │
│  │                       │    │                    │     etcd      │
│  │       ByteView        │    │                    │   Registry    │
│  │  - b []byte           │    │                    │               │
│  │                       │    │                    └───────┬───────┘
│  └───────────────────────┘    │                            │
│                               │                            │
└───────────────────────────────┘                            │
                │                                            │
                ▼                                            ▼
┌───────────────────────────────┐            ┌───────────────────────────┐
│         store Package         │            │          Server           │
│                               │            │  - addr                   │
│  ┌───────────────────────┐    │            │  - svcName                │
│  │                       │    │            │  - groups                 │
│  │         Store         │    │            │  - grpcServer             │
│  │       Interface       │    │            │  - etcdCli                │
│  │                       │    │            │                           │
│  └───────────┬───────────┘    │            └───────────────────────────┘
│              │                │
│              ▼                │             ┌──────────────────────────┐
│  ┌───────────────────────┐    │             │                          │
│  │      Store Impls      │    │             │       Protobuf API       │
│  │  ┌─────────┐ ┌──────┐ │    │             │  - LCacheServer          │
│  │  │  LRU2   │ │  LRU │ │    │             │  - Request/Response      │
│  │  └─────────┘ └──────┘ │    │             │                          │
│  └───────────────────────┘    │             └──────────────────────────┘
│                               │
└───────────────────────────────┘
    ┌───────────────────────────────┐
    │       Helper Components       │
    │                               │
    │  ┌─────────────────────────┐  │
    │  │     consistenthash      │  │
    │  │  - Map                  │  │
    │  │  - LoadBalancing        │  │
    │  └─────────────────────────┘  │
    │                               │
    │  ┌─────────────────────────┐  │
    │  │      singleflight       │  │
    │  │  - Group                │  │
    │  │  - call                 │  │
    │  └─────────────────────────┘  │
    │                               │
    └───────────────────────────────┘
</code></pre><hr><h3 id=数据存储层><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e5%b1%82></a>数据存储层</h3><h4 id=byteview><a class=header-anchor href=#byteview></a>ByteView</h4><p><code>ByteView</code> 是缓存值的不可变视图，用于防止缓存数据被外部修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>ByteView</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=w> </span><span class=p>[]</span><span class=kt>byte</span><span class=w>  </span><span class=c1>// 存储的实际数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 返回数据副本，而不是直接返回原始切片</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=nx>ByteView</span><span class=p>)</span><span class=w> </span><span class=nf>ByteSlice</span><span class=p>()</span><span class=w> </span><span class=p>[]</span><span class=kt>byte</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nf>cloneBytes</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>b</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=store-接口><a class=header-anchor href=#store-%e6%8e%a5%e5%8f%a3></a>Store 接口</h4><p>定义了缓存存储的抽象接口，支持多种缓存实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Store</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Set</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>SetWithExpiration</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=nx>expiration</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Clear</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Len</span><span class=p>()</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Close</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=lru><a class=header-anchor href=#lru></a>LRU</h4><p>传统的 LRU 算法实现，基于标准库 <code>container/list</code> 实现双向链表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>lruCache</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w>              </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>list</span><span class=w>            </span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>List</span><span class=w>               </span><span class=c1>// 双向链表，用于维护 LRU 顺序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>items</span><span class=w>           </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>Element</span><span class=w> </span><span class=c1>// 键到链表节点的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>expires</span><span class=w>         </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=w>     </span><span class=c1>// 过期时间映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>maxBytes</span><span class=w>        </span><span class=kt>int64</span><span class=w>                    </span><span class=c1>// 最大允许字节数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>usedBytes</span><span class=w>       </span><span class=kt>int64</span><span class=w>                    </span><span class=c1>// 当前使用的字节数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>onEvicted</span><span class=w>       </span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupInterval</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupTicker</span><span class=w>   </span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Ticker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>closeCh</span><span class=w>         </span><span class=kd>chan</span><span class=w> </span><span class=kd>struct</span><span class=p>{}</span><span class=w>            </span><span class=c1>// 用于优雅关闭清理协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=lru2><a class=header-anchor href=#lru2></a>LRU2</h4><p>两级 LRU 缓存实现，将数据分散到多个桶中，提高并发性能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>lru2Store</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>locks</span><span class=w>       </span><span class=p>[]</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>  </span><span class=c1>// 分段锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>caches</span><span class=w>      </span><span class=p>[][</span><span class=mi>2</span><span class=p>]</span><span class=o>*</span><span class=nx>cache</span><span class=w>   </span><span class=c1>// 两级缓存：[桶索引][级别]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>onEvicted</span><span class=w>   </span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupTick</span><span class=w> </span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Ticker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mask</span><span class=w>        </span><span class=kt>int32</span><span class=w>         </span><span class=c1>// 哈希掩码，用于快速定位桶</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>主要特点</strong>：</p><ul><li>分段锁提高并发性能</li><li>两级缓存结构，提高缓存命中率</li><li>自定义双向链表实现，减少内存分配</li><li>高效的哈希函数和桶映射</li></ul><hr><h3 id=缓存核心层><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e6%a0%b8%e5%bf%83%e5%b1%82></a>缓存核心层</h3><h4 id=cache><a class=header-anchor href=#cache></a>Cache</h4><p><code>Cache</code> 是底层缓存存储的封装，管理底层存储实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Cache</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w>          </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>store</span><span class=w>       </span><span class=nx>store</span><span class=p>.</span><span class=nx>Store</span><span class=w>   </span><span class=c1>// 底层存储实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>opts</span><span class=w>        </span><span class=nx>CacheOptions</span><span class=w>  </span><span class=c1>// 缓存配置选项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hits</span><span class=w>        </span><span class=kt>int64</span><span class=w>         </span><span class=c1>// 缓存命中次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>misses</span><span class=w>      </span><span class=kt>int64</span><span class=w>         </span><span class=c1>// 缓存未命中次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>initialized</span><span class=w> </span><span class=kt>int32</span><span class=w>         </span><span class=c1>// 原子变量，标记缓存是否已初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>closed</span><span class=w>      </span><span class=kt>int32</span><span class=w>         </span><span class=c1>// 原子变量，标记缓存是否已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=group><a class=header-anchor href=#group></a>Group</h4><p><code>Group</code> 是缓存的命名空间，提供对特定数据集合的缓存管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Group</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>name</span><span class=w>       </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>getter</span><span class=w>     </span><span class=nx>Getter</span><span class=w>           </span><span class=c1>// 数据加载接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mainCache</span><span class=w>  </span><span class=o>*</span><span class=nx>Cache</span><span class=w>           </span><span class=c1>// 本地缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>peers</span><span class=w>      </span><span class=nx>PeerPicker</span><span class=w>       </span><span class=c1>// 节点选择器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loader</span><span class=w>     </span><span class=o>*</span><span class=nx>singleflight</span><span class=p>.</span><span class=nx>Group</span><span class=w> </span><span class=c1>// 请求合并</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>expiration</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=w>    </span><span class=c1>// 缓存过期时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>closed</span><span class=w>     </span><span class=kt>int32</span><span class=w>            </span><span class=c1>// 标记组是否已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>stats</span><span class=w>      </span><span class=nx>groupStats</span><span class=w>       </span><span class=c1>// 统计信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>核心功能</strong>：</p><ul><li>缓存未命中时从数据源加载</li><li>防止缓存穿透和缓存击穿</li><li>支持分布式节点间数据同步</li><li>详细的统计信息收集</li></ul><hr><h3 id=分布式协调层><a class=header-anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e5%8d%8f%e8%b0%83%e5%b1%82></a>分布式协调层</h3><h4 id=一致性哈希><a class=header-anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c></a>一致性哈希</h4><p>基于一致性哈希算法的节点选择实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Map</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>config</span><span class=w>       </span><span class=o>*</span><span class=nx>Config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>keys</span><span class=w>         </span><span class=p>[]</span><span class=kt>int</span><span class=w>          </span><span class=c1>// 哈希环</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hashMap</span><span class=w>      </span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=w> </span><span class=c1>// 哈希环到节点的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>nodeReplicas</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=w> </span><span class=c1>// 节点到虚拟节点数量的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>nodeCounts</span><span class=w>   </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int64</span><span class=w> </span><span class=c1>// 节点负载统计</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>totalRequests</span><span class=w> </span><span class=kt>int64</span><span class=w>         </span><span class=c1>// 总请求数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>特点</strong>：</p><ul><li>支持动态添加/删除节点</li><li>自动负载均衡</li><li>虚拟节点机制减少数据倾斜</li></ul><h4 id=singleflight><a class=header-anchor href=#singleflight></a>SingleFlight</h4><p>防止缓存击穿的请求合并机制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Group</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span><span class=w> </span><span class=c1>// 使用 sync.Map 优化并发性能</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 针对相同的 key，保证多次调用 Do() 都只会调用一次 fn</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Do</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>fn</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>))</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... 实现代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>核心思想</strong>：对于同一个 key 的并发请求，只执行一次实际的加载操作，其他请求共享结果。</p><h4 id=服务注册与发现><a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c%e4%b8%8e%e5%8f%91%e7%8e%b0></a>服务注册与发现</h4><p>基于 etcd 的服务注册与发现。</p><hr><h3 id=网络通信层><a class=header-anchor href=#%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1%e5%b1%82></a>网络通信层</h3><ul><li><strong>gRPC 客户端</strong></li><li><strong>gRPC 服务端</strong></li></ul><hr><h2 id=设计模式与最佳实践><a class=header-anchor href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5></a>设计模式与最佳实践</h2><h3 id=使用的设计模式><a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f></a>使用的设计模式</h3><ul><li><strong>单例模式</strong>：全局缓存组注册表</li><li><strong>工厂方法</strong>：创建不同类型的缓存存储</li><li><strong>策略模式</strong>：不同的缓存淘汰算法</li><li><strong>代理模式</strong>：客户端代理远程缓存操作</li><li><strong>组合模式</strong>：缓存组织结构</li></ul><h3 id=性能优化技巧><a class=header-anchor href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%8a%80%e5%b7%a7></a>性能优化技巧</h3><ul><li><strong>预分配内存</strong>：减少动态内存分配</li><li><strong>批量操作</strong>：减少系统调用</li><li><strong>分段锁</strong>：减少锁竞争</li><li><strong>异步处理</strong>：非关键路径使用异步操作</li><li><strong>惰性删除</strong>：标记删除而非立即物理删除</li></ul><h3 id=扩展性设计><a class=header-anchor href=#%e6%89%a9%e5%b1%95%e6%80%a7%e8%ae%be%e8%ae%a1></a>扩展性设计</h3><ul><li><strong>接口抽象</strong>：<code>Store</code>、<code>Getter</code>、<code>PeerPicker</code> 等接口</li><li><strong>选项模式</strong>：使用函数选项模式配置组件</li><li><strong>中间件思想</strong>：可插拔的组件设计</li></ul><hr><h1 id=21-项目部署和运行><a class=header-anchor href=#21-%e9%a1%b9%e7%9b%ae%e9%83%a8%e7%bd%b2%e5%92%8c%e8%bf%90%e8%a1%8c></a>2.1 项目部署和运行</h1><p>本地缓存一般运行于服务器上，因此需要使用 Linux 系统或 macOS 系统运行本项目。也可使用虚拟机或 Windows 的 WSL 来模拟环境。<br>项目依赖于 etcd 作为注册中心，因此需要提前启动 etcd 并设置好端口和地址。为避免复杂性，建议直接用 Docker 启动 etcd。</p><h2 id=1-安装><a class=header-anchor href=#1-%e5%ae%89%e8%a3%85></a>1. 安装</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get github.com/youngyangyang04/KamaCache-Go
</span></span></code></pre></div><h2 id=2-启动-etcd><a class=header-anchor href=#2-%e5%90%af%e5%8a%a8-etcd></a>2. 启动 etcd</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 使用 Docker 启动 etcd</span>
</span></span><span class=line><span class=cl>docker run -d --name etcd <span class=se>\
</span></span></span><span class=line><span class=cl>  -p 2379:2379 <span class=se>\
</span></span></span><span class=line><span class=cl>  quay.io/coreos/etcd:v3.5.0 <span class=se>\
</span></span></span><span class=line><span class=cl>  etcd --advertise-client-urls http://0.0.0.0:2379 <span class=se>\
</span></span></span><span class=line><span class=cl>       --listen-client-urls http://0.0.0.0:2379
</span></span></code></pre></div><h2 id=3-运行示例><a class=header-anchor href=#3-%e8%bf%90%e8%a1%8c%e7%a4%ba%e4%be%8b></a>3. 运行示例</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 启动，地址: %s&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>addr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 创建节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span><span class=w> </span><span class=s>&#34;kama-cache&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>WithEtcdEndpoints</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;localhost:2379&#34;</span><span class=p>}),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>WithDialTimeout</span><span class=p>(</span><span class=mi>5</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;创建节点失败:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 创建节点选择器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>picker</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>NewClientPicker</span><span class=p>(</span><span class=nx>addr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;创建节点选择器失败:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 创建缓存组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>group</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>NewGroup</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>,</span><span class=w> </span><span class=nx>lcache</span><span class=p>.</span><span class=nf>GetterFunc</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 触发数据源加载: key=%s&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;节点%s的数据源值&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)),</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 注册节点选择器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>group</span><span class=p>.</span><span class=nf>RegisterPeers</span><span class=p>(</span><span class=nx>picker</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 启动节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 开始启动服务...&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>node</span><span class=p>.</span><span class=nf>Start</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;启动节点失败:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 等待节点注册完成</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 等待节点注册...&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>5</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>ctx</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 设置本节点的特定键值对</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>localKey</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;key_%s&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>localValue</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;这是节点%s的数据&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\n=== 节点%s：设置本地数据 ===\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>err</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>localKey</span><span class=p>,</span><span class=w> </span><span class=nx>localValue</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;设置本地数据失败:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;节点%s: 设置键 %s 成功\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>localKey</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 等待其他节点也完成设置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 等待其他节点准备就绪...&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>30</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 打印当前已发现的节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>picker</span><span class=p>.</span><span class=nf>PrintPeers</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 测试获取本地数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\n=== 节点%s：获取本地数据 ===\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;直接查询本地缓存...\n&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 打印缓存统计信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>stats</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Stats</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;缓存统计: %+v\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>stats</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>val</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>localKey</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;节点%s: 获取本地键 %s 成功: %s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>localKey</span><span class=p>,</span><span class=w> </span><span class=nx>val</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;节点%s: 获取本地键失败: %v\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 测试获取其他节点的数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>otherKeys</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;key_A&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;key_B&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;key_C&#34;</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>otherKeys</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>localKey</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>continue</span><span class=w> </span><span class=c1>// 跳过本节点的键</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\n=== 节点%s：尝试获取远程数据 %s ===\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[节点%s] 开始查找键 %s 的远程节点&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>val</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;节点%s: 获取远程键 %s 成功: %s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>val</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;节点%s: 获取远程键失败: %v\n&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=nx>nodeID</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 保持程序运行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></div><h3 id=4-多节点部署><a class=header-anchor href=#4-%e5%a4%9a%e8%8a%82%e7%82%b9%e9%83%a8%e7%bd%b2></a>4. 多节点部署</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 启动节点 A</span>
</span></span><span class=line><span class=cl>go run example/test.go -port <span class=m>8001</span> -node A
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动节点 B</span>
</span></span><span class=line><span class=cl>go run example/test.go -port <span class=m>8002</span> -node B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动节点 C</span>
</span></span><span class=line><span class=cl>go run example/test.go -port <span class=m>8003</span> -node C
</span></span></code></pre></div><hr><h1 id=3-缓存组><a class=header-anchor href=#3-%e7%bc%93%e5%ad%98%e7%bb%84></a>3. 缓存组</h1><p>缓存组是一个命名空间，管理特定类别数据的缓存，提供了数据的获取、设置、删除等基本操作，同时负责缓存未命中时的数据加载和分布式节点间的数据同步。</p><p>该模块将缓存、分布式通信和数据加载策略融为一体，通过单飞（<code>singleflight</code>）机制防止缓存击穿，通过分布式协议保持数据一致性，通过统计指标监控缓存效率，是整个 LCache 系统的中枢组件。</p><hr><h2 id=核心结构设计><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1></a>核心结构设计</h2><h3 id=全局缓存组管理><a class=header-anchor href=#%e5%85%a8%e5%b1%80%e7%bc%93%e5%ad%98%e7%bb%84%e7%ae%a1%e7%90%86></a>全局缓存组管理</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>groupsMu</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>groups</span><span class=w>   </span><span class=p>=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>使用全局映射表管理所有缓存组，通过读写锁保证并发安全：</p><ul><li><code>groups</code>：名称到缓存组的映射</li><li><code>groupsMu</code>：保护映射的读写锁</li></ul><h3 id=数据加载接口><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e5%8a%a0%e8%bd%bd%e6%8e%a5%e5%8f%a3></a>数据加载接口</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Getter 加载键值的回调函数接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Getter</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// GetterFunc 函数类型实现 Getter 接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>GetterFunc</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Get 实现 Getter 接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>f</span><span class=w> </span><span class=nx>GetterFunc</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nf>f</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>Getter</code> 接口定义了缓存未命中时从数据源加载数据的方法：</p><ul><li>接受上下文和键作为输入</li><li>返回字节切片和可能的错误</li></ul><h3 id=缓存组结构><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e7%bb%84%e7%bb%93%e6%9e%84></a>缓存组结构</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Group 是一个缓存命名空间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Group</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>name</span><span class=w>       </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>getter</span><span class=w>     </span><span class=nx>Getter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mainCache</span><span class=w>  </span><span class=o>*</span><span class=nx>Cache</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>peers</span><span class=w>      </span><span class=nx>PeerPicker</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loader</span><span class=w>     </span><span class=o>*</span><span class=nx>singleflight</span><span class=p>.</span><span class=nx>Group</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>expiration</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=w> </span><span class=c1>// 缓存过期时间，0表示永不过期</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>closed</span><span class=w>     </span><span class=kt>int32</span><span class=w>         </span><span class=c1>// 原子变量，标记组是否已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>stats</span><span class=w>      </span><span class=nx>groupStats</span><span class=w>    </span><span class=c1>// 统计信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// groupStats 保存组的统计信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>groupStats</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loads</span><span class=w>        </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 加载次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>localHits</span><span class=w>    </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 本地缓存命中次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>localMisses</span><span class=w>  </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 本地缓存未命中次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>peerHits</span><span class=w>     </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 从对等节点获取成功次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>peerMisses</span><span class=w>   </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 从对等节点获取失败次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loaderHits</span><span class=w>   </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 从加载器获取成功次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loaderErrors</span><span class=w> </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 从加载器获取失败次数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loadDuration</span><span class=w> </span><span class=kt>int64</span><span class=w> </span><span class=c1>// 加载总耗时（纳秒）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>Group</code> 结构体是整个缓存系统的核心，包含以下关键字段：</p><ul><li><code>name</code>：缓存组名称，唯一标识</li><li><code>getter</code>：数据加载回调，缓存未命中时调用</li><li><code>mainCache</code>：本地缓存实例</li><li><code>peers</code>：分布式节点选择器</li><li><code>loader</code>：单飞组，防止缓存击穿</li><li><code>expiration</code>：缓存过期时间</li><li><code>closed</code>：组是否已关闭标志</li><li><code>stats</code>：统计信息</li></ul><hr><h2 id=核心功能实现><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0></a>核心功能实现</h2><h3 id=数据获取><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e8%8e%b7%e5%8f%96></a>数据获取</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Get 从缓存获取数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>ByteView</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查组是否已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>closed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{},</span><span class=w> </span><span class=nx>ErrGroupClosed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{},</span><span class=w> </span><span class=nx>ErrKeyRequired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从本地缓存获取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>mainCache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>localHits</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>localMisses</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 尝试从其他节点获取或加载</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>load</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>数据获取流程</strong>：</p><ol><li>状态检查：验证组是否处于活跃状态</li><li>参数验证：确保键不为空</li><li>本地缓存：尝试从本地缓存获取数据</li><li>统计更新：记录本地命中或未命中</li><li>加载数据：缓存未命中时加载数据</li></ol><p>这个流程体现了缓存的基本思想：先查本地，未命中则加载。同时通过原子操作安全地更新统计数据。</p><h3 id=数据加载><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e5%8a%a0%e8%bd%bd></a>数据加载</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// load 加载数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>load</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>ByteView</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 使用 singleflight 确保并发请求只加载一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>startTime</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>viewi</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>loader</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>loadData</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 记录加载时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>loadDuration</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>startTime</span><span class=p>).</span><span class=nf>Nanoseconds</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>loadDuration</span><span class=p>,</span><span class=w> </span><span class=nx>loadDuration</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>loads</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>loaderErrors</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{},</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>view</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>viewi</span><span class=p>.(</span><span class=nx>ByteView</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 设置到本地缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>expiration</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>g</span><span class=p>.</span><span class=nx>mainCache</span><span class=p>.</span><span class=nf>AddWithExpiration</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>expiration</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>g</span><span class=p>.</span><span class=nx>mainCache</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>view</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// loadData 实际加载数据的方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>loadData</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>ByteView</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 尝试从远程节点获取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>peers</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>peer</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=p>,</span><span class=w> </span><span class=nx>isSelf</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>peers</span><span class=p>.</span><span class=nf>PickPeer</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>!</span><span class=nx>isSelf</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>getFromPeer</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>peer</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>peerHits</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>peerMisses</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>logrus</span><span class=p>.</span><span class=nf>Warnf</span><span class=p>(</span><span class=s>&#34;[LCache] failed to get from peer: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从数据源加载</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>bytes</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>getter</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{},</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to get data: %w&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>stats</span><span class=p>.</span><span class=nx>loaderHits</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{</span><span class=nx>b</span><span class=p>:</span><span class=w> </span><span class=nf>cloneBytes</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)},</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// getFromPeer 从其他节点获取数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>getFromPeer</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>peer</span><span class=w> </span><span class=nx>Peer</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>ByteView</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>bytes</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>peer</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{},</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to get from peer: %w&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{</span><span class=nx>b</span><span class=p>:</span><span class=w> </span><span class=nx>bytes</span><span class=p>},</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>数据加载的多层次流程</strong>：</p><ol><li><strong>单飞机制</strong>：使用 <code>singleflight</code> 防止缓存击穿</li><li><strong>性能监控</strong>：记录加载时间和次数</li><li><strong>分布式查询</strong>：先尝试从其他节点获取</li><li><strong>源数据加载</strong>：如果分布式查询失败，从数据源加载</li><li><strong>结果缓存</strong>：将加载的数据设置到本地缓存</li><li><strong>统计更新</strong>：记录各类加载结果的统计信息</li></ol><p>这个设计充分体现了分布式缓存的优势：利用整个集群的缓存能力，减轻单个节点的负担，同时降低对原始数据源的访问压力。</p><h3 id=数据设置><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e8%ae%be%e7%bd%ae></a>数据设置</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Set 设置缓存值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=p>[]</span><span class=kt>byte</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查组是否已关闭</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>g</span><span class=p>.</span><span class=nx>closed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ErrGroupClosed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ErrKeyRequired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>ErrValueRequired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查是否是从其他节点同步过来的请求</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>isPeerRequest</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;from_peer&#34;</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建缓存视图</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>view</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ByteView</span><span class=p>{</span><span class=nx>b</span><span class=p>:</span><span class=w> </span><span class=nf>cloneBytes</span><span class=p>(</span><span class=nx>value</span><span class=p>)}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 设置到本地缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>expiration</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>g</span><span class=p>.</span><span class=nx>mainCache</span><span class=p>.</span><span class=nf>AddWithExpiration</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>expiration</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>g</span><span class=p>.</span><span class=nx>mainCache</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>view</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果不是从其他节点同步过来的请求，且启用了分布式模式，同步到其他节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>isPeerRequest</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>peers</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>go</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>syncToPeers</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=s>&#34;set&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>数据设置流程</strong>：</p><ol><li>状态检查：验证组是否已关闭</li><li>参数验证：确保键和值都有效</li><li>请求来源检查：区分本地请求和远程同步请求</li><li>本地缓存更新：设置到本地缓存</li><li>分布式同步：本地请求时异步同步到其他节点</li></ol><p>请求来源区分很重要，它防止了缓存操作的无限循环传播，确保每个更新只在集群中同步一次。</p><h3 id=分布式操作同步><a class=header-anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e6%93%8d%e4%bd%9c%e5%90%8c%e6%ad%a5></a>分布式操作同步</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// syncToPeers 同步操作到其他节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>syncToPeers</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>op</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=p>[]</span><span class=kt>byte</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>peers</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 选择对等节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>peer</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=p>,</span><span class=w> </span><span class=nx>isSelf</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>peers</span><span class=p>.</span><span class=nf>PickPeer</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>ok</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>isSelf</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建同步请求上下文</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>syncCtx</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;from_peer&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>switch</span><span class=w> </span><span class=nx>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>case</span><span class=w> </span><span class=s>&#34;set&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>err</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>peer</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>syncCtx</span><span class=p>,</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>case</span><span class=w> </span><span class=s>&#34;delete&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>peer</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>logrus</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;[LCache] failed to sync %s to peer: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>op</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>分布式同步的关键流程</strong>：</p><ol><li>节点选择：使用一致性哈希选择目标节点</li><li>标记来源：在上下文中标记这是一个同步请求</li><li>操作分发：根据操作类型调用相应的远程方法</li><li>错误处理：记录同步失败的日志</li></ol><p>通过标记同步请求的来源，解决了分布式系统中的环形传播问题，确保每个操作只在集群中传播一次。</p><hr><h2 id=功能特定分析><a class=header-anchor href=#%e5%8a%9f%e8%83%bd%e7%89%b9%e5%ae%9a%e5%88%86%e6%9e%90></a>功能特定分析</h2><h3 id=多级缓存架构><a class=header-anchor href=#%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98%e6%9e%b6%e6%9e%84></a>多级缓存架构</h3><p>KamaCache 实现了典型的多级缓存架构：</p><ol><li><strong>本地缓存</strong>：最快，但容量有限</li><li><strong>远程节点缓存</strong>：次快，扩大了有效缓存容量</li><li><strong>数据源</strong>：最慢，但提供完整数据</li></ol><p>这种架构类似于 CPU 的缓存层次结构，通过空间换时间的策略提高数据访问速度。当数据在本地缓存中找不到时，会尝试从远程节点获取，进一步降低对原始数据源的访问频率。</p><h3 id=防止击穿><a class=header-anchor href=#%e9%98%b2%e6%ad%a2%e5%87%bb%e7%a9%bf></a>防止击穿</h3><p>缓存击穿是指热点数据过期瞬间，大量请求同时涌入数据源的现象。LCache 通过 <code>singleflight</code> 机制有效防止了这个问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>viewi</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>loader</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nf>loadData</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>})</span><span class=w>
</span></span></span></code></pre></div><p><code>singleflight</code> 确保对同一个键的并发请求只执行一次加载操作，其他请求等待并共享结果，这样可以：</p><ol><li>减轻数据源负担</li><li>避免重复计算</li><li>提高响应速度</li><li>减少资源消耗</li></ol><hr><h1 id=4-缓存淘汰与实现><a class=header-anchor href=#4-%e7%bc%93%e5%ad%98%e6%b7%98%e6%b1%b0%e4%b8%8e%e5%ae%9e%e7%8e%b0></a>4. 缓存淘汰与实现</h1><h2 id=最近最少使用lru><a class=header-anchor href=#%e6%9c%80%e8%bf%91%e6%9c%80%e5%b0%91%e4%bd%bf%e7%94%a8lru></a>最近最少使用（LRU）</h2><h3 id=算法原理><a class=header-anchor href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86></a>算法原理</h3><p>LRU 认为最近使用的数据在未来仍可能被访问，因此它会淘汰最久未被使用的数据。</p><h3 id=实现方式><a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f></a>实现方式</h3><ol><li>使用双向链表维护数据，新插入的数据放在链表头部。</li><li>每次访问数据，将该数据移到链表头部，表示它是最近使用的数据。</li><li>当缓存满时，淘汰链表尾部的数据（即最近最少使用的数据）。</li><li>使用哈希表存储 key 和链表节点的映射，提高访问效率。</li></ol><h3 id=优缺点><a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9></a>优缺点</h3><p><strong>优点</strong></p><ul><li>充分利用数据的时间局部性，能较好适应大多数缓存场景。</li><li>实现相对简单，查询效率高（O(1)）。</li></ul><p><strong>缺点</strong></p><ul><li>在批量操作场景下，可能导致缓存污染，如周期性批量任务可能清空缓存，导致缓存命中率下降。</li></ul><hr><h3 id=kamacache-的实现><a class=header-anchor href=#kamacache-%e7%9a%84%e5%ae%9e%e7%8e%b0></a>KamaCache 的实现</h3><h4 id=数据结构设计><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1></a>数据结构设计</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>lruCache</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w>              </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>           </span><span class=c1>// 读写锁，保证并发安全</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>list</span><span class=w>            </span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>List</span><span class=w>            </span><span class=c1>// 双向链表，用于维护 LRU 顺序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>items</span><span class=w>           </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>Element</span><span class=w> </span><span class=c1>// 键到链表节点的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>expires</span><span class=w>         </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=w>  </span><span class=c1>// 过期时间映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>maxBytes</span><span class=w>        </span><span class=kt>int64</span><span class=w>                 </span><span class=c1>// 最大允许字节数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>usedBytes</span><span class=w>       </span><span class=kt>int64</span><span class=w>                 </span><span class=c1>// 当前使用的字节数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>onEvicted</span><span class=w>       </span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w> </span><span class=c1>// 淘汰回调</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupInterval</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=w>         </span><span class=c1>// 清理间隔</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupTicker</span><span class=w>   </span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Ticker</span><span class=w>          </span><span class=c1>// 定时器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>closeCh</span><span class=w>         </span><span class=kd>chan</span><span class=w> </span><span class=kd>struct</span><span class=p>{}</span><span class=w>         </span><span class=c1>// 关闭通道</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>关键设计点</strong>：</p><ul><li>双向链表 + 哈希表：结合 Go 标准库的 <code>container/list</code> 和内置 map 实现 O(1) 的查找和更新操作</li><li>读写锁：区分读写操作使用 <code>sync.RWMutex</code>，提高并发性能</li><li>过期时间映射：独立的 <code>expires</code> 映射，用于快速判断和管理项目过期</li><li>内存追踪：通过 <code>maxBytes</code> 和 <code>usedBytes</code> 限制和追踪内存使用</li><li>资源回收：通过 <code>onEvicted</code> 回调在删除缓存项时执行自定义逻辑</li><li>自动清理：使用 goroutine 和定时器实现后台自动清理</li></ul><h4 id=获取缓存项><a class=header-anchor href=#%e8%8e%b7%e5%8f%96%e7%bc%93%e5%ad%98%e9%a1%b9></a>获取缓存项</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>lruCache</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查是否过期</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>expTime</span><span class=p>,</span><span class=w> </span><span class=nx>hasExp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>expires</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span><span class=w> </span><span class=nx>hasExp</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>After</span><span class=p>(</span><span class=nx>expTime</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 异步删除过期项，避免在读锁内操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>go</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 获取值并释放读锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>entry</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>lruEntry</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>value</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 更新 LRU 位置需要写锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 再次检查元素是否仍然存在</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>MoveToBack</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>实现要点</strong>：</p><ol><li>先使用读锁检查项目是否存在和过期</li><li>如果过期，异步删除该项（避免在读锁中修改数据）</li><li>使用写锁更新 LRU 顺序（将访问的项移到链表尾部）</li><li>使用二段锁定策略，减少锁的持有时间</li></ol><h4 id=设置缓存项><a class=header-anchor href=#%e8%ae%be%e7%bd%ae%e7%bc%93%e5%ad%98%e9%a1%b9></a>设置缓存项</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>lruCache</span><span class=p>)</span><span class=w> </span><span class=nf>Set</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nf>SetWithExpiration</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>lruCache</span><span class=p>)</span><span class=w> </span><span class=nf>SetWithExpiration</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=nx>expiration</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 计算过期时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>expTime</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>expiration</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>expTime</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=nx>expiration</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>expires</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>expTime</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>delete</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>expires</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果键已存在，更新值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>oldEntry</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>lruEntry</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>usedBytes</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>value</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>oldEntry</span><span class=p>.</span><span class=nx>value</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>oldEntry</span><span class=p>.</span><span class=nx>value</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>MoveToBack</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 添加新项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>entry</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>lruEntry</span><span class=p>{</span><span class=nx>key</span><span class=p>:</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=p>:</span><span class=w> </span><span class=nx>value</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>elem</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>entry</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>elem</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>usedBytes</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>value</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 检查是否需要淘汰旧项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nf>evict</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>实现要点</strong>：</p><ul><li>支持可选的过期时间设置</li><li>对于已存在的项，更新值并调整内存使用计数</li><li>添加新项时，更新映射和链表</li><li>每次添加后触发 <code>evict</code> 检查是否需要淘汰</li></ul><h4 id=淘汰策略><a class=header-anchor href=#%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5></a>淘汰策略</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>lruCache</span><span class=p>)</span><span class=w> </span><span class=nf>removeElement</span><span class=p>(</span><span class=nx>elem</span><span class=w> </span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>Element</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>entry</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>elem</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>lruEntry</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>delete</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>delete</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>expires</span><span class=p>,</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>usedBytes</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>entry</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>value</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>onEvicted</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nf>onEvicted</span><span class=p>(</span><span class=nx>entry</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>lruCache</span><span class=p>)</span><span class=w> </span><span class=nf>evict</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 先清理过期项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>now</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>expTime</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>expires</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>now</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=nx>expTime</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>elem</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>c</span><span class=p>.</span><span class=nf>removeElement</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 再根据内存限制清理最久未使用的项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>maxBytes</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>usedBytes</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>maxBytes</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>elem</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nf>Front</span><span class=p>()</span><span class=w> </span><span class=c1>// 获取最久未使用的项（链表头部）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>elem</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>c</span><span class=p>.</span><span class=nf>removeElement</span><span class=p>(</span><span class=nx>elem</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>淘汰策略分两步</strong>：</p><ol><li>清理所有已过期的项</li><li>如果设置了内存限制，且当前使用的内存超过限制，从链表头部开始淘汰（最久未使用的项）</li></ol><hr><h2 id=lru-kleast-recently-used-k><a class=header-anchor href=#lru-kleast-recently-used-k></a>LRU-K（Least Recently Used K）</h2><h3 id=算法原理-1><a class=header-anchor href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86-1></a>算法原理</h3><p>LRU-K 通过维护访问历史，只有当数据被访问 K 次后，才将其放入缓存，以减少缓存污染。</p><h3 id=实现方式-1><a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f-1></a>实现方式</h3><ol><li>所有数据首次访问时，进入历史访问队列。</li><li>如果数据访问次数达到 K 次，才放入 LRU 缓存队列。</li><li>当缓存满时，淘汰“倒数第 K 次访问距离当前时间最长的数据”。</li></ol><h3 id=优缺点-1><a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-1></a>优缺点</h3><p><strong>优点</strong></p><ul><li>减少缓存污染，更适用于数据访问模式复杂的场景。<br><strong>缺点</strong></li><li>需要维护额外的历史访问队列，占用更多内存。</li></ul><hr><h2 id=lru-2least-recently-used-2><a class=header-anchor href=#lru-2least-recently-used-2></a>LRU-2（Least Recently Used 2）</h2><h3 id=算法原理-2><a class=header-anchor href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86-2></a>算法原理</h3><p>LRU-2 是 LRU-K 算法的特例（K=2），即只有当某个数据被访问至少两次后，才可能被缓存。相比传统 LRU 更能抵抗缓存污染，适用于访问模式中存在临时热点的情况。</p><h3 id=实现方式-2><a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f-2></a>实现方式</h3><ol><li>首次访问的数据被记录在历史访问队列（非缓存队列）中。</li><li>当同一数据被第二次访问时，将其移入实际的 LRU 缓存队列。</li><li>LRU 缓存队列按最近访问顺序维护，最久未使用的数据靠前。</li><li>缓存满时，淘汰 LRU 缓存队列中最久未访问的数据。</li></ol><h3 id=优缺点-2><a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-2></a>优缺点</h3><p><strong>优点</strong></p><ul><li>能有效过滤一次性访问数据，减少缓存污染。</li><li>相比 LRU-K 更易实现，性能开销较小。</li></ul><p><strong>缺点</strong></p><ul><li>与 LRU 相比，仍需维护一个额外的历史访问队列。</li><li>如果访问频率极低，则可能长时间无法进入缓存，影响命中率。</li></ul><hr><h3 id=kamacache-的实现-1><a class=header-anchor href=#kamacache-%e7%9a%84%e5%ae%9e%e7%8e%b0-1></a>KamaCache 的实现</h3><h4 id=核心设计理念><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5></a>核心设计理念</h4><ul><li><strong>两级 LRU 策略</strong>：解决传统 LRU 的“缓存污染”问题</li><li><strong>分桶并发</strong>：通过水平分片减少锁竞争</li><li><strong>内存预分配</strong>：避免运行时内存分配，减少 GC 压力</li><li><strong>索引化双向链表</strong>：使用数组索引代替指针，提升缓存局部性</li><li><strong>自定义时钟</strong>：减少系统调用，提升时间获取性能</li><li><strong>主动+被动过期</strong>：确保过期数据及时清理</li></ul><h4 id=节点结构node><a class=header-anchor href=#%e8%8a%82%e7%82%b9%e7%bb%93%e6%9e%84node></a>节点结构（node）</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>k</span><span class=w>        </span><span class=kt>string</span><span class=w> </span><span class=c1>// 键</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>v</span><span class=w>        </span><span class=nx>Value</span><span class=w>  </span><span class=c1>// 值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>expireAt</span><span class=w> </span><span class=kt>int64</span><span class=w>  </span><span class=c1>// 过期时间戳，expireAt = 0 表示已删除</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>最小化内存占用：只包含必要的三个字段</li><li>过期标记复用：使用 <code>expireAt = 0</code> 表示节点已删除，避免额外的标记字段</li><li>类型抽象：<code>Value</code> 是接口类型，支持存储任意类型的值</li></ul><h4 id=缓存结构><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e7%bb%93%e6%9e%84></a>缓存结构</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>cache</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>dlnk</span><span class=w> </span><span class=p>[][</span><span class=mi>2</span><span class=p>]</span><span class=kt>uint16</span><span class=w>       </span><span class=c1>// 双向链表，0 表示前驱，1 表示后继</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=w>    </span><span class=p>[]</span><span class=nx>node</span><span class=w>            </span><span class=c1>// 预分配内存存储节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hmap</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>uint16</span><span class=w> </span><span class=c1>// 键到节点索引的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>last</span><span class=w> </span><span class=kt>uint16</span><span class=w>            </span><span class=c1>// 最后一个节点元素的索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><p><strong>索引化双向链表（<code>dlnk</code>）</strong></p><ul><li>不使用传统指针链表，而是用索引数组</li><li><code>dlnk[i][0]</code> 存储节点 i 的前驱索引</li><li><code>dlnk[i][1]</code> 存储节点 i 的后继索引</li><li><code>dlnk[0]</code> 作为哨兵节点，<code>dlnk[0][0]</code> 存储尾节点索引，<code>dlnk[0][1]</code> 存储头节点索引</li></ul></li><li><p><strong>预分配内存池（<code>m</code>）</strong></p><ul><li>启动时预分配固定大小的节点数组</li><li>避免运行时动态分配内存</li><li>通过索引复用节点，减少 GC 压力</li></ul></li><li><p><strong>快速查找映射（<code>hmap</code>）</strong></p><ul><li>从键直接映射到节点索引</li><li>实现 O(1) 的查找复杂度</li></ul></li><li><p><strong>内存管理（<code>last</code>）</strong></p><ul><li>跟踪已分配的节点数量</li><li>用于判断是否需要驱逐老数据</li></ul></li></ol><p><strong>内存布局示例</strong>：</p><pre tabindex=0><code>dlnk 数组布局:
[0]: [尾索引, 头索引]  // 哨兵节点
[1]: [前驱, 后继]     // 节点1的链表关系
[2]: [前驱, 后继]     // 节点2的链表关系
...

m 数组布局:
[0]: {key1, value1, expireAt1}  // 对应 dlnk[1]
[1]: {key2, value2, expireAt2}  // 对应 dlnk[2]
...
</code></pre><h4 id=主缓存结构><a class=header-anchor href=#%e4%b8%bb%e7%bc%93%e5%ad%98%e7%bb%93%e6%9e%84></a>主缓存结构</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>lru2Store</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>locks</span><span class=w>       </span><span class=p>[]</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>                    </span><span class=c1>// 每个桶的独立锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>caches</span><span class=w>      </span><span class=p>[][</span><span class=mi>2</span><span class=p>]</span><span class=o>*</span><span class=nx>cache</span><span class=w>                    </span><span class=c1>// 每个桶包含两级缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>onEvicted</span><span class=w>   </span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w>  </span><span class=c1>// 驱逐回调函数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cleanupTick</span><span class=w> </span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Ticker</span><span class=w>                   </span><span class=c1>// 定期清理定时器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mask</span><span class=w>        </span><span class=kt>int32</span><span class=w>                          </span><span class=c1>// 用于哈希取模的掩码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><p><strong>分桶并发控制（<code>locks</code> + <code>caches</code>）</strong></p><ul><li>将数据分散到多个桶中，每个桶独立加锁</li><li>减少锁竞争，提升并发性能</li><li>桶数量为 2 的幂，便于使用位运算快速定位</li></ul></li><li><p><strong>两级缓存架构（<code>caches[][2]*cache</code>）</strong></p><ul><li><code>caches[i][0]</code>：第 i 个桶的一级缓存（频次过滤器）</li><li><code>caches[i][1]</code>：第 i 个桶的二级缓存（热点数据）</li><li>新数据进入一级缓存，二次访问才进入二级缓存</li></ul></li><li><p><strong>事件通知机制（<code>onEvicted</code>）</strong></p><ul><li>当数据被驱逐时触发回调</li><li>支持应用层进行额外的清理操作</li></ul></li></ol><hr><h2 id=最少使用频率lfu><a class=header-anchor href=#%e6%9c%80%e5%b0%91%e4%bd%bf%e7%94%a8%e9%a2%91%e7%8e%87lfu></a>最少使用频率（LFU）</h2><h3 id=算法原理-3><a class=header-anchor href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86-3></a>算法原理</h3><p>LFU 通过统计数据的访问次数来决定淘汰策略，使用次数最少的数据将被淘汰。</p><h3 id=实现方式-3><a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f-3></a>实现方式</h3><ol><li>新数据插入缓存时，设置其访问计数为 1，并放入队列。</li><li>每次访问缓存中的数据，该数据的访问计数加 1，并重新调整队列排序，使得访问次数较少的数据靠后。</li><li>当缓存满时，淘汰访问次数最少的数据（即队列末尾数据）。</li><li>为了优化查询速度，可以使用哈希表存储数据，结合优先队列（heap）或平衡二叉搜索树进行访问频率排序。</li></ol><h3 id=优缺点-3><a class=header-anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-3></a>优缺点</h3><p><strong>优点</strong></p><ul><li>对高频访问的数据有较好优化，能提升热点数据的命中率。</li><li>适用于访问频率稳定的场景，如 AI 训练数据缓存、热点文章推荐系统等。</li></ul><p><strong>缺点</strong></p><ul><li>实现复杂度较高，需要额外的存储来维护访问频率。</li><li>无法应对短期热点数据，如果某个数据短时间内访问次数较多，但随后不再访问，可能会导致缓存污染（Cold Start 问题）。</li></ul><hr><h1 id=5-缓存并发><a class=header-anchor href=#5-%e7%bc%93%e5%ad%98%e5%b9%b6%e5%8f%91></a>5. 缓存并发</h1><p>当系统面临突发流量时，缓存层可能成为性能瓶颈：</p><h2 id=缓存击穿cache-breakdown><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bfcache-breakdown></a>缓存击穿（Cache Breakdown）</h2><ul><li><strong>现象</strong>：热点 key 过期瞬间，大量请求穿透缓存直达数据库</li><li><strong>后果</strong>：数据库瞬时压力陡增（案例：电商大促期间因秒杀商品 key 失效导致 DB 过载）</li></ul><h2 id=缓存雪崩cache-avalanche><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9cache-avalanche></a>缓存雪崩（Cache Avalanche）</h2><ul><li><strong>现象</strong>：大量 key 集中过期或缓存集群宕机</li><li><strong>后果</strong>：请求洪峰压垮后端系统（案例：社交平台定时批量刷新缓存引发服务中断）</li></ul><h2 id=缓存穿透cache-penetration><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8fcache-penetration></a>缓存穿透（Cache Penetration）</h2><ul><li><strong>现象</strong>：恶意请求不存在的数据（如负向 ID 查询）</li><li><strong>后果</strong>：缓存完全失效，持续冲击数据库（案例：金融系统遭恶意爬虫攻击）</li></ul><hr><p>为了应对突发性的缓存失效导致大量请求直接打到数据库，KamaCache 采用了 <strong>SingleFlight</strong> 机制。</p><h2 id=singleflight-1><a class=header-anchor href=#singleflight-1></a>SingleFlight</h2><ul><li><strong>请求折叠</strong>：将并发请求合并为单个实际调用</li><li><strong>零等待优化</strong>：首个请求完成后立即释放等待协程</li><li><strong>无锁架构</strong>：基于 <code>sync.Map</code> 实现无锁并发控制</li></ul><h3 id=核心数据结构><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84></a>核心数据结构</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>call</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>wg</span><span class=w>  </span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=w> </span><span class=c1>// 协程同步器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>val</span><span class=w> </span><span class=kd>interface</span><span class=p>{}</span><span class=w>    </span><span class=c1>// 执行结果容器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>err</span><span class=w> </span><span class=kt>error</span><span class=w>          </span><span class=c1>// 错误信息容器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Group</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span><span class=w> </span><span class=c1>// 并发安全存储（key:string → value:*call）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=实现><a class=header-anchor href=#%e5%ae%9e%e7%8e%b0></a>实现</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>g</span><span class=w> </span><span class=o>*</span><span class=nx>Group</span><span class=p>)</span><span class=w> </span><span class=nf>Do</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>fn</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>))</span><span class=w> </span><span class=p>(</span><span class=kd>interface</span><span class=p>{},</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 存在性检查（无锁快速路径）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>existing</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>g</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=nx>key</span><span class=p>);</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>existing</span><span class=p>.(</span><span class=o>*</span><span class=nx>call</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>c</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w> </span><span class=c1>// 等待正在进行的请求</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 慢速路径（初始化请求）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>new</span><span class=p>(</span><span class=nx>call</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>g</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 执行实际函数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>err</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>fn</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 异步清理（避免阻塞返回）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>g</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>实现要点</strong>：</p><ul><li><strong>双重检查锁模式</strong>：<code>Load</code> 检查 → <code>Store</code> 写入，减少锁竞争</li><li><strong>异步清理策略</strong>：立即返回结果后清理映射表</li><li><strong>零内存分配</strong>：<code>call</code> 对象复用（可配合对象池优化）</li></ul><hr><h1 id=6-分布式算法之一致性哈希><a class=header-anchor href=#6-%e5%88%86%e5%b8%83%e5%bc%8f%e7%ae%97%e6%b3%95%e4%b9%8b%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c></a>6. 分布式算法之一致性哈希</h1><p>在分布式缓存系统中，<strong>一致性哈希</strong>（Consistent Hashing）是一种常用的负载均衡策略，用于解决缓存节点的动态扩展和缩容问题。它可以减少缓存失效率，提高缓存命中率，从而提高系统的可扩展性和稳定性。</p><h2 id=为什么需要一致性哈希><a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c></a>为什么需要一致性哈希？</h2><p>在分布式缓存系统中，多个服务器（缓存节点）存储不同的缓存数据，客户端需要决定将某个 key 存储在哪个缓存节点。最简单的方式是使用<strong>取模（Modulo）分片</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 传统哈希分片示例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>getShard</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>nodeCount</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hash</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>crc32</span><span class=p>.</span><span class=nf>ChecksumIEEE</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>key</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nx>hash</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=nx>nodeCount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=节点数量变化了怎么办><a class=header-anchor href=#%e8%8a%82%e7%82%b9%e6%95%b0%e9%87%8f%e5%8f%98%e5%8c%96%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e></a>节点数量变化了怎么办？</h3><p>这种方式存在以下问题：</p><ul><li>当节点数量变更时，大量 key 的缓存映射会发生变化，导致缓存命中率大幅下降。</li><li>数据迁移成本高，每次增加或删除节点，都需要重新计算所有 key 的存储位置。</li></ul><p>简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设移除了其中一台节点，只剩下 9 个，那么之前 <code>hash(key) % 10</code> 变成了 <code>hash(key) % 9</code>，也就意味着几乎缓存值对应的节点都发生了改变，即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起<strong>缓存雪崩</strong>。</p><p>一致性哈希算法可以解决这个问题。</p><hr><h3 id=算法原理-4><a class=header-anchor href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86-4></a>算法原理</h3><p>一致性哈希使用一个虚拟的哈希环（0~2³²），所有缓存节点和 key 通过哈希函数（如 MurmurHash、FNV-1a）映射到环上的某个位置。</p><ul><li><strong>节点映射</strong>：将缓存节点的 IP 或名称进行哈希计算，并映射到哈希环上。</li><li><strong>数据映射</strong>：将 key 计算哈希值，并找到顺时针方向最近的节点，作为 key 的存储位置。</li></ul><h3 id=步骤><a class=header-anchor href=#%e6%ad%a5%e9%aa%a4></a>步骤</h3><p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p><ol><li>计算节点（通常使用节点的名称、编号和 IP 地址）的哈希值，放置在环上。</li><li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。</li></ol><p><img src=https://cdn.nlark.com/yuque/0/2025/png/12925030/1742216420294-93d9e2f7-aaa1-4234-bbe7-f1b274b64aaf.png alt=一致性哈希示意图></p><p>环上有 peer2、peer4、peer6 三个节点，key11、key2、key27 均映射到 peer2，key23 映射到 peer4。此时，如果新增节点 peer8，假设它新增位置如图所示，那么只有 key27 从 peer2 调整到 peer8，其余的映射均没有发生改变。</p><p>也就是说，一致性哈希算法在新增/删除节点时，只需要重新定位该节点附近的一小部分数据，而不需要重新定位所有的节点。</p><hr><h3 id=数据倾斜问题><a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e5%80%be%e6%96%9c%e9%97%ae%e9%a2%98></a>数据倾斜问题</h3><p>如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2、peer4、peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。</p><p>为了解决这个问题，引入了<strong>虚拟节点</strong>的概念，一个真实节点对应多个虚拟节点。</p><p>假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、peer1-2、peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。</p><ul><li>第一步，计算虚拟节点的 Hash 值，放置在环上。</li><li>第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。</li></ul><p>虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题，且代价非常小，只需要增加一个字典维护真实节点与虚拟节点的映射关系即可。</p><hr><h2 id=kamacache-实现><a class=header-anchor href=#kamacache-%e5%ae%9e%e7%8e%b0></a>KamaCache 实现</h2><h4 id=核心数据结构-1><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1></a>核心数据结构</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Map</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>           </span><span class=c1>// 读写锁，保证并发安全</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>config</span><span class=w> </span><span class=o>*</span><span class=nx>Config</span><span class=w>           </span><span class=c1>// 配置信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>keys</span><span class=w> </span><span class=p>[]</span><span class=kt>int</span><span class=w>               </span><span class=c1>// 哈希环上的所有虚拟节点位置，按顺序排列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hashMap</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>string</span><span class=w>   </span><span class=c1>// 从哈希值到实际节点名称的映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>nodeReplicas</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=w> </span><span class=c1>// 每个实际节点对应的虚拟节点数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>nodeCounts</span><span class=w> </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int64</span><span class=w> </span><span class=c1>// 记录每个节点处理的请求数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>totalRequests</span><span class=w> </span><span class=kt>int64</span><span class=w>       </span><span class=c1>// 记录总请求数，用于负载均衡计算</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>mu</code>: 读写互斥锁，允许多个读操作并发执行，写操作独占锁。</li><li><code>config</code>: 存储配置信息，包含哈希函数、默认虚拟节点数等。</li><li><code>keys</code>: 有序整数数组，存储所有虚拟节点的哈希位置，按升序排列以便二分查找。</li><li><code>hashMap</code>: 将哈希环上的位置映射到实际节点名称。</li><li><code>nodeReplicas</code>: 记录每个实际节点当前拥有的虚拟节点数量，用于负载均衡调整。</li><li><code>nodeCounts</code>: 统计每个节点处理的请求数量，作为负载均衡的依据。</li><li><code>totalRequests</code>: 记录总请求数，用于计算平均负载。</li></ul><h4 id=节点管理><a class=header-anchor href=#%e8%8a%82%e7%82%b9%e7%ae%a1%e7%90%86></a>节点管理</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>Add</span><span class=p>(</span><span class=nx>nodes</span><span class=w> </span><span class=o>...</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>nodes</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;no nodes provided&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>nodes</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 为节点添加虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>m</span><span class=p>.</span><span class=nf>addNode</span><span class=p>(</span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>DefaultReplicas</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 重新排序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>addNode</span><span class=p>(</span><span class=nx>node</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>replicas</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>replicas</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>hash</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nf>HashFunc</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s-%d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>i</span><span class=p>))))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>,</span><span class=w> </span><span class=nx>hash</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>m</span><span class=p>.</span><span class=nx>hashMap</span><span class=p>[</span><span class=nx>hash</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>replicas</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>Remove</span><span class=p>(</span><span class=nx>node</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;invalid node&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>replicas</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>replicas</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;node %s not found&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 移除节点的所有虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>replicas</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>hash</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nf>HashFunc</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s-%d&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>i</span><span class=p>))))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>hashMap</span><span class=p>,</span><span class=w> </span><span class=nx>hash</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=nx>j</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>j</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>);</span><span class=w> </span><span class=nx>j</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>hash</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>[:</span><span class=nx>j</span><span class=p>],</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>j</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span><span class=o>...</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=p>,</span><span class=w> </span><span class=nx>node</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=请求路由><a class=header-anchor href=#%e8%af%b7%e6%b1%82%e8%b7%af%e7%94%b1></a>请求路由</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>hash</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nf>HashFunc</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>key</span><span class=p>)))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 二分查找</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>idx</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sort</span><span class=p>.</span><span class=nf>Search</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>),</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=nx>hash</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 处理边界情况</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>idx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>idx</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>node</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>hashMap</span><span class=p>[</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>[</span><span class=nx>idx</span><span class=p>]]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>count</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>totalRequests</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>路由查找的详细过程</strong>：</p><ol><li>参数校验：确保键不为空</li><li>加读锁：允许多个查找操作并发进行</li><li>检查哈希环是否为空</li><li>使用相同的哈希函数计算键的哈希值</li><li>使用标准库的 <code>sort.Search</code> 进行二分查找，寻找第一个大于或等于该哈希值的位置</li><li>处理特殊情况：如果没有找到大于或等于的位置，表示应该环绕到哈希环的起点</li><li>通过哈希映射获取对应的实际节点名称</li><li>更新请求统计计数（读锁允许修改不影响并发安全的局部变量）</li><li>使用原子操作增加总请求计数</li></ol><p>二分查找保证了查找操作的时间复杂度为 <strong>O(log n)</strong>，其中 n 是虚拟节点的总数。</p><h4 id=负载均衡机制><a class=header-anchor href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e6%9c%ba%e5%88%b6></a>负载均衡机制</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>checkAndRebalance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>totalRequests</span><span class=p>)</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=c1>// 样本太少，不进行调整</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 计算负载情况</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>avgLoad</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>float64</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>totalRequests</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nb>float64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>maxDiff</span><span class=w> </span><span class=kt>float64</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>count</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>diff</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>math</span><span class=p>.</span><span class=nf>Abs</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>count</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>avgLoad</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>diff</span><span class=o>/</span><span class=nx>avgLoad</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>maxDiff</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>maxDiff</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>diff</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nx>avgLoad</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果负载不均衡度超过阈值，调整虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>maxDiff</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>LoadBalanceThreshold</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>m</span><span class=p>.</span><span class=nf>rebalanceNodes</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>m</span><span class=w> </span><span class=o>*</span><span class=nx>Map</span><span class=p>)</span><span class=w> </span><span class=nf>rebalanceNodes</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>avgLoad</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>float64</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>totalRequests</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nb>float64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 调整每个节点的虚拟节点数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>count</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>currentReplicas</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeReplicas</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>loadRatio</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>float64</span><span class=p>(</span><span class=nx>count</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nx>avgLoad</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>newReplicas</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>loadRatio</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 负载过高，减少虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>currentReplicas</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nx>loadRatio</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 负载过低，增加虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>currentReplicas</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>loadRatio</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 确保在限制范围内</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>MinReplicas</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>MinReplicas</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>MaxReplicas</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>newReplicas</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>MaxReplicas</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>newReplicas</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>currentReplicas</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 重新添加节点的虚拟节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>node</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=w> </span><span class=c1>// 如果移除失败，跳过这个节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>m</span><span class=p>.</span><span class=nf>addNode</span><span class=p>(</span><span class=nx>node</span><span class=p>,</span><span class=w> </span><span class=nx>newReplicas</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 重置计数器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>m</span><span class=p>.</span><span class=nx>nodeCounts</span><span class=p>[</span><span class=nx>node</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreInt64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>totalRequests</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 重新排序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>sort</span><span class=p>.</span><span class=nf>Ints</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>keys</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>负载均衡检查流程</strong>：</p><ol><li>检查总请求数是否达到有效样本（1000），避免样本太少导致调整不准确</li><li>计算平均负载：总请求数 ÷ 节点数</li><li>计算最大负载偏差率：找出偏离平均负载最远的节点，计算其偏差占平均负载的比例</li><li>如果最大偏差超过配置的阈值，触发重新平衡操作</li></ol><p><strong>重新平衡算法</strong>：</p><ul><li>加写锁：确保在重新平衡期间没有其他操作</li><li>重新计算平均负载</li><li>遍历每个节点，计算其负载比率（相对于平均负载）</li><li>根据负载比率调整虚拟节点数量：<ul><li>负载过高（比率>1）：按比例减少虚拟节点</li><li>负载过低（比率&lt;1）：增加虚拟节点，增加幅度为 <code>(2 - loadRatio)</code> 倍</li></ul></li><li>确保虚拟节点数量在配置的范围内</li><li>先移除该节点所有虚拟节点，再用新的数量重新添加</li><li>重置所有计数器，准备下一轮统计</li><li>重新排序哈希环</li></ul><hr><h2 id=一致性哈希是分布式算法吗><a class=header-anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f%e7%ae%97%e6%b3%95%e5%90%97></a>一致性哈希是分布式算法吗？</h2><p>严格来说，一致性哈希本身并不是一个分布式算法，而是一种用于分布式系统的<strong>数据分布策略</strong>。</p><p>它的主要作用是在分布式存储或缓存系统中，将数据均匀地映射到不同的节点上，从而减少节点增删时的数据迁移，提高系统的可扩展性和稳定性。</p><p>虽然一致性哈希本身并不涉及节点间的通信和协调，但它是许多分布式算法的基础，比如：</p><ul><li>分布式缓存（Groupcache、Memcached）</li><li>分布式存储（Amazon DynamoDB、Cassandra）</li><li>负载均衡（Nginx、Consul）</li></ul><p>在分布式系统中，一致性哈希常用于<strong>无中心化</strong>（decentralized）的架构，如 P2P 网络或去中心化存储。</p><hr><h3 id=与-redis-的不同之处><a class=header-anchor href=#%e4%b8%8e-redis-%e7%9a%84%e4%b8%8d%e5%90%8c%e4%b9%8b%e5%a4%84></a>与 Redis 的不同之处</h3><table><thead><tr><th>对比项</th><th>KamaCache</th><th>Redis</th></tr></thead><tbody><tr><td>架构类型</td><td>P2P（无中心化）分布式缓存</td><td>基于主从的集中式分布式缓存</td></tr><tr><td>数据存储</td><td>每个实例都有部分缓存，数据由一致性哈希决定</td><td>数据存储在独立的 Redis 服务器或 Redis Cluster</td></tr><tr><td>节点间通信</td><td>节点互相发现，通过 Peer-to-Peer 直接访问</td><td>客户端-服务器模式，需要专门的 Redis 服务器</td></tr><tr><td>数据一致性</td><td>只缓存数据，依赖于底层数据库保证数据一致性</td><td>通过主从复制（Replication）保证数据同步</td></tr></tbody></table><h4 id=一致性哈希的作用><a class=header-anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%9a%84%e4%bd%9c%e7%94%a8></a>一致性哈希的作用</h4><ul><li><strong>Groupcache</strong>：使用一致性哈希决定数据存放在哪个缓存节点。</li><li><strong>Redis（单实例）</strong>：直接存储数据，不涉及一致性哈希。</li><li><strong>Redis Cluster</strong>：使用哈希槽（Hash Slot）机制，通过 <code>CRC16(key) % 16384</code> 计算哈希槽，将 key 分片存储在不同的 Redis 节点上。</li></ul><hr><h3 id=适用于哪些场景><a class=header-anchor href=#%e9%80%82%e7%94%a8%e4%ba%8e%e5%93%aa%e4%ba%9b%e5%9c%ba%e6%99%af></a>适用于哪些场景？</h3><p>KamaCache 是一个分布式缓存，适用于：</p><ul><li>无中心化的分布式架构（如微服务、P2P 系统）</li><li>高性能读缓存，尤其适用于防止缓存击穿</li><li>避免集中式缓存的瓶颈，如单点 Redis 服务器的性能限制</li></ul><hr><h1 id=7-缓存对外服务化><a class=header-anchor href=#7-%e7%bc%93%e5%ad%98%e5%af%b9%e5%a4%96%e6%9c%8d%e5%8a%a1%e5%8c%96></a>7. 缓存对外服务化</h1><p>每个 KamaCache 进程在哈希环中都是其中的一个节点，环中不同节点要互相通信，因此必须对外提供服务。</p><hr><h2 id=服务端模块><a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%a8%a1%e5%9d%97></a>服务端模块</h2><p>服务端模块是缓存系统对外提供服务的核心，负责接收和处理来自其他节点的请求。<br>KamaCache 使用 <strong>gRPC</strong> 进行节点间的通信，同时集成了服务注册发现、健康检查和安全传输等特性。</p><h3 id=核心结构设计-1><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1-1></a>核心结构设计</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Server 定义缓存服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Server</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>pb</span><span class=p>.</span><span class=nx>UnimplementedLCacheServer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>addr</span><span class=w>       </span><span class=kt>string</span><span class=w>           </span><span class=c1>// 服务地址</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>svcName</span><span class=w>    </span><span class=kt>string</span><span class=w>           </span><span class=c1>// 服务名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>groups</span><span class=w>     </span><span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span><span class=w>        </span><span class=c1>// 缓存组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>grpcServer</span><span class=w> </span><span class=o>*</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>Server</span><span class=w>     </span><span class=c1>// gRPC 服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>etcdCli</span><span class=w>    </span><span class=o>*</span><span class=nx>clientv3</span><span class=p>.</span><span class=nx>Client</span><span class=w> </span><span class=c1>// etcd 客户端</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>stopCh</span><span class=w>     </span><span class=kd>chan</span><span class=w> </span><span class=kt>error</span><span class=w>       </span><span class=c1>// 停止信号</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>opts</span><span class=w>       </span><span class=o>*</span><span class=nx>ServerOptions</span><span class=w>   </span><span class=c1>// 服务器选项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>Server</code> 结构体是服务器模块的核心，包含以下关键字段：</p><ul><li><code>UnimplementedLCacheServer</code>：gRPC 自动生成的基类，提供接口默认实现</li><li><code>addr</code>：服务监听地址，格式为 <code>IP:Port</code></li><li><code>svcName</code>：服务名称，用于在服务注册中心标识服务</li><li><code>groups</code>：本地缓存组映射表，使用 <code>sync.Map</code> 保证并发安全</li><li><code>grpcServer</code>：gRPC 服务器实例</li><li><code>etcdCli</code>：etcd 客户端，用于服务注册</li><li><code>stopCh</code>：停止信号通道，用于服务优雅停止</li><li><code>opts</code>：服务器配置选项</li></ul><h3 id=服务创建和生命周期管理><a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e5%88%9b%e5%bb%ba%e5%92%8c%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%ae%a1%e7%90%86></a>服务创建和生命周期管理</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// NewServer 创建新的服务器实例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span><span class=w> </span><span class=nx>svcName</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>opts</span><span class=w> </span><span class=o>...</span><span class=nx>ServerOption</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>Server</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>options</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>DefaultServerOptions</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>opt</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>opts</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>opt</span><span class=p>(</span><span class=nx>options</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建 etcd 客户端</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>etcdCli</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>clientv3</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>clientv3</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>Endpoints</span><span class=p>:</span><span class=w>   </span><span class=nx>options</span><span class=p>.</span><span class=nx>EtcdEndpoints</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>DialTimeout</span><span class=p>:</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>DialTimeout</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to create etcd client: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建 gRPC 服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>serverOpts</span><span class=w> </span><span class=p>[]</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>ServerOption</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>serverOpts</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>serverOpts</span><span class=p>,</span><span class=w> </span><span class=nx>grpc</span><span class=p>.</span><span class=nf>MaxRecvMsgSize</span><span class=p>(</span><span class=nx>options</span><span class=p>.</span><span class=nx>MaxMsgSize</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>TLS</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>creds</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>loadTLSCredentials</span><span class=p>(</span><span class=nx>options</span><span class=p>.</span><span class=nx>CertFile</span><span class=p>,</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>KeyFile</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to load TLS credentials: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>serverOpts</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>serverOpts</span><span class=p>,</span><span class=w> </span><span class=nx>grpc</span><span class=p>.</span><span class=nf>Creds</span><span class=p>(</span><span class=nx>creds</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>srv</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>Server</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>addr</span><span class=p>:</span><span class=w>       </span><span class=nx>addr</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>svcName</span><span class=p>:</span><span class=w>    </span><span class=nx>svcName</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>groups</span><span class=p>:</span><span class=w>     </span><span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span><span class=p>{},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>grpcServer</span><span class=p>:</span><span class=w> </span><span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>serverOpts</span><span class=o>...</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>etcdCli</span><span class=p>:</span><span class=w>    </span><span class=nx>etcdCli</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>stopCh</span><span class=p>:</span><span class=w>     </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>error</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>opts</span><span class=p>:</span><span class=w>       </span><span class=nx>options</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注册服务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>pb</span><span class=p>.</span><span class=nf>RegisterLCacheServer</span><span class=p>(</span><span class=nx>srv</span><span class=p>.</span><span class=nx>grpcServer</span><span class=p>,</span><span class=w> </span><span class=nx>srv</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注册健康检查服务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>healthServer</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>health</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>healthpb</span><span class=p>.</span><span class=nf>RegisterHealthServer</span><span class=p>(</span><span class=nx>srv</span><span class=p>.</span><span class=nx>grpcServer</span><span class=p>,</span><span class=w> </span><span class=nx>healthServer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>healthServer</span><span class=p>.</span><span class=nf>SetServingStatus</span><span class=p>(</span><span class=nx>svcName</span><span class=p>,</span><span class=w> </span><span class=nx>healthpb</span><span class=p>.</span><span class=nx>HealthCheckResponse_SERVING</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>srv</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Start 启动服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=o>*</span><span class=nx>Server</span><span class=p>)</span><span class=w> </span><span class=nf>Start</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 启动 gRPC 服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>lis</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>.</span><span class=nx>addr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to listen: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注册到 etcd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>stopCh</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>registry</span><span class=p>.</span><span class=nf>Register</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>svcName</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>.</span><span class=nx>addr</span><span class=p>,</span><span class=w> </span><span class=nx>stopCh</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>logrus</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to register service: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>close</span><span class=p>(</span><span class=nx>stopCh</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>logrus</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;Server starting at %s&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>.</span><span class=nx>addr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>s</span><span class=p>.</span><span class=nx>grpcServer</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>服务创建流程</strong>：</p><ol><li>应用配置选项：合并默认选项和用户提供的选项</li><li>创建 etcd 客户端：用于服务注册</li><li>配置 gRPC 服务器：设置最大消息大小和可选的 TLS 加密</li><li>创建服务器实例：初始化 <code>Server</code> 结构体</li><li>注册 gRPC 服务：将缓存服务实现注册到 gRPC 服务器</li><li>添加健康检查服务：支持 gRPC 健康检查协议</li></ol><p><strong>服务启动过程</strong>：</p><ol><li>创建网络监听器：在指定地址上监听 TCP 连接</li><li>服务注册：将服务信息注册到 etcd，使其对其他节点可见</li><li>启动 gRPC 服务：开始处理客户端请求</li></ol><p>服务注册是异步执行的，避免阻塞主服务启动流程。</p><h3 id=缓存操作接口><a class=header-anchor href=#%e7%bc%93%e5%ad%98%e6%93%8d%e4%bd%9c%e6%8e%a5%e5%8f%a3></a>缓存操作接口</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Get 实现 LCache 服务的 Get 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=o>*</span><span class=nx>Server</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>ResponseForGet</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>group</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>GetGroup</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>group</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;group %s not found&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>view</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=nx>pb</span><span class=p>.</span><span class=nx>ResponseForGet</span><span class=p>{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=nx>view</span><span class=p>.</span><span class=nf>ByteSlice</span><span class=p>()},</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Set 实现 LCache 服务的 Set 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>s</span><span class=w> </span><span class=o>*</span><span class=nx>Server</span><span class=p>)</span><span class=w> </span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>ResponseForGet</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>group</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>GetGroup</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>group</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;group %s not found&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从 context 中获取标记，如果没有则创建新的 context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fromPeer</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;from_peer&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>fromPeer</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>ctx</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=s>&#34;from_peer&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>group</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Key</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Value</span><span class=p>);</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=nx>pb</span><span class=p>.</span><span class=nx>ResponseForGet</span><span class=p>{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>Value</span><span class=p>},</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>获取缓存的处理流程</strong>：</p><ol><li>查找缓存组：根据请求中的组名找到对应的缓存组</li><li>获取缓存值：调用缓存组的 <code>Get</code> 方法获取数据</li><li>构造响应：将获取的数据封装到响应中返回</li></ol><p><strong>设置缓存的处理流程</strong>：</p><ol><li>查找缓存组：根据请求中的组名找到对应的缓存组</li><li>标记来源：在上下文中添加标记，表明请求来自对等节点，避免循环传播</li><li>设置缓存值：调用缓存组的 <code>Set</code> 方法存储数据</li><li>构造响应：将原始值封装到响应中返回</li></ol><p>这里的 <code>from_peer</code> 标记非常重要，它防止了缓存更新无限传播的问题，是分布式缓存系统中的关键设计。</p><hr><h2 id=节点选择器><a class=header-anchor href=#%e8%8a%82%e7%82%b9%e9%80%89%e6%8b%a9%e5%99%a8></a>节点选择器</h2><p>采用一致性哈希算法进行节点选择，结合 etcd 实现动态服务发现，是连接客户端和服务端的桥梁。</p><p>本模块解决了分布式缓存中的核心问题：</p><ol><li>如何在多个缓存节点之间均匀分布数据</li><li>如何动态感知节点的加入和退出</li><li>如何在节点变化时最小化数据迁移</li><li>如何选择合适的节点处理特定的缓存请求</li></ol><h3 id=核心接口设计><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1></a>核心接口设计</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PeerPicker 定义了 peer 选择器的接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>PeerPicker</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>PickPeer</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>peer</span><span class=w> </span><span class=nx>Peer</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=nx>self</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Close</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>PeerPicker</code> 是节点选择器的抽象接口，定义了两个核心方法：</p><ul><li><code>PickPeer</code>：根据键选择合适的缓存节点，返回节点实例、是否找到、是否为本地节点</li><li><code>Close</code>：关闭选择器并释放资源</li></ul><p>这种抽象设计使得节点选择策略可以灵活更换，例如可以实现基于地理位置、负载情况或其他策略的选择器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Peer 定义了缓存节点的接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Peer</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Get</span><span class=p>(</span><span class=nx>group</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=w> </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span><span class=w> </span><span class=nx>group</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=p>[]</span><span class=kt>byte</span><span class=p>)</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Delete</span><span class=p>(</span><span class=nx>group</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=kt>error</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>Close</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>Peer</code> 接口定义了缓存节点的基本操作：</p><ul><li><code>Get</code>：获取缓存数据</li><li><code>Set</code>：设置缓存数据</li><li><code>Delete</code>：删除缓存数据</li><li><code>Close</code>：关闭节点连接并释放资源</li></ul><p>该接口是对远程缓存节点操作的抽象，隐藏了底层通信细节，使得上层应用可以用统一的方式操作本地或远程缓存。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ClientPicker 实现了 PeerPicker 接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>ClientPicker</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>selfAddr</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>svcName</span><span class=w>  </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mu</span><span class=w>       </span><span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>consHash</span><span class=w> </span><span class=o>*</span><span class=nx>consistenthash</span><span class=p>.</span><span class=nx>Map</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>clients</span><span class=w>  </span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>Client</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>etcdCli</span><span class=w>  </span><span class=o>*</span><span class=nx>clientv3</span><span class=p>.</span><span class=nx>Client</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>ctx</span><span class=w>      </span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cancel</span><span class=w>   </span><span class=nx>context</span><span class=p>.</span><span class=nx>CancelFunc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>ClientPicker</code> 是 <code>PeerPicker</code> 接口的核心实现，包含以下关键字段：</p><ul><li><code>selfAddr</code>：当前节点的地址，用于识别自身</li><li><code>svcName</code>：服务名称，用于服务发现</li><li><code>mu</code>：读写互斥锁，保证并发安全</li><li><code>consHash</code>：一致性哈希实现，用于节点选择</li><li><code>clients</code>：节点地址到客户端的映射</li><li><code>etcdCli</code>：etcd 客户端，用于服务发现</li><li><code>ctx</code> 和 <code>cancel</code>：上下文和取消函数，用于控制生命周期</li></ul><p>这种设计将节点选择、客户端管理和服务发现集成在一起，形成一个完整的节点管理解决方案。</p><h3 id=服务发现与节点管理><a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0%e4%b8%8e%e8%8a%82%e7%82%b9%e7%ae%a1%e7%90%86></a>服务发现与节点管理</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// startServiceDiscovery 启动服务发现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>ClientPicker</span><span class=p>)</span><span class=w> </span><span class=nf>startServiceDiscovery</span><span class=p>()</span><span class=w> </span><span class=kt>error</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 先进行全量更新</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>fetchAllServices</span><span class=p>();</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 启动增量更新</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>go</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>watchServiceChanges</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>服务发现分为两个阶段</strong>：</p><ol><li><strong>全量更新</strong>：获取当前所有可用的服务节点</li><li><strong>增量更新</strong>：监听节点变化并实时更新</li></ol><p>这种设计确保了选择器能够立即获取当前的完整节点列表，并在后续及时感知节点的变化。</p><h3 id=一致性哈希与节点选择><a class=header-anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e4%b8%8e%e8%8a%82%e7%82%b9%e9%80%89%e6%8b%a9></a>一致性哈希与节点选择</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PickPeer 选择 peer 节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>ClientPicker</span><span class=p>)</span><span class=w> </span><span class=nf>PickPeer</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>Peer</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>defer</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>addr</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>consHash</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=p>);</span><span class=w> </span><span class=nx>addr</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>client</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>clients</span><span class=p>[</span><span class=nx>addr</span><span class=p>];</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nx>client</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=nx>addr</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>selfAddr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>节点选择流程</strong>：</p><ol><li>获取读锁，确保并发安全</li><li>使用一致性哈希算法根据键选择地址</li><li>查找对应地址的客户端</li><li>返回客户端、是否找到、是否为本地节点</li></ol><p>这个实现的返回值包括三个部分：</p><ul><li><strong>客户端实例</strong>：用于进行后续操作</li><li><strong>是否找到节点</strong>：表示选择是否成功</li><li><strong>是否为本地节点</strong>：区分本地操作和远程操作</li></ul><hr><h1 id=8-简历写法><a class=header-anchor href=#8-%e7%ae%80%e5%8e%86%e5%86%99%e6%b3%95></a>8. 简历写法</h1><p>推荐使用 <a href=https://jianli.kamacoder.com/>卡码简历</a> 制作简历，高效方便。</p><h2 id=项目分布式缓存系统-lcache><a class=header-anchor href=#%e9%a1%b9%e7%9b%ae%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98%e7%b3%bb%e7%bb%9f-lcache></a>项目：分布式缓存系统 LCache</h2><p><strong>项目描述</strong><br>基于 Go 语言实现的高性能分布式缓存系统，支持多种缓存淘汰策略和分布式协调机制。项目设计注重系统的可扩展性、高并发性和容错性，实现了在分布式环境下的高效数据共享和访问。</p><p><strong>个人工作</strong></p><ul><li>实现了 LRU 和 LRU2 缓存淘汰算法，针对不同访问模式优化缓存命中率；</li><li>设计实现了自适应一致性哈希算法，支持虚拟节点和动态负载均衡，确保数据均匀分布；</li><li>实现了分段锁和两级缓存结构，有效减少锁争用，提升高并发场景下的系统吞吐量；</li><li>实现了基于 SingleFlight 的请求合并机制，防止缓存击穿，降低后端服务压力；</li><li>基于 etcd 设计实现了服务注册发现模块，支持自动节点管理和健康检查；</li><li>实现了基于 gRPC 的高性能节点间通信协议，保证分布式环境下的数据一致性；</li><li>设计实现了优雅关闭和资源回收机制，确保系统稳定性和资源释放。</li></ul><p><strong>项目难点</strong></p><ol><li><strong>分布式一致性保证</strong>：设计并实现节点间数据同步协议，确保在节点增删和网络分区情况下的数据一致性；</li><li><strong>高并发设计</strong>：通过分段锁、原子操作和无锁数据结构，优化高并发下的系统性能；</li><li><strong>缓存穿透和击穿防护</strong>：设计实现请求合并和过期策略，防止缓存失效导致的系统压力；</li><li><strong>动态负载均衡</strong>：实现自适应一致性哈希算法，在保证数据分布均匀的同时支持动态节点管理；</li><li><strong>高效内存管理</strong>：通过预分配内存和双层缓存结构，减少 GC 压力并提高内存利用率。</li></ol><p><strong>个人收获</strong></p><ol><li>深入理解了分布式系统设计原则和最佳实践，特别是在数据一致性和可用性方面；</li><li>掌握了高并发编程技术，包括细粒度锁设计、原子操作和无锁编程；</li><li>提升了 Go 语言在系统级编程中的应用能力，特别是在协程和通道管理方面；</li><li>学习了各种缓存淘汰策略的实现和优化方法，以及在实际场景中的应用；</li><li>掌握了基于 etcd 的分布式协调技术和服务发现机制；</li><li>增强了对系统性能分析和优化的能力，能够识别瓶颈并进行有针对性的改进。</li></ol><hr><h1 id=9-常见面试题><a class=header-anchor href=#9-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98></a>9. 常见面试题</h1><h4 id=1-什么是缓存><a class=header-anchor href=#1-%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98></a>1. 什么是缓存？</h4><p><strong>答</strong>：缓存，就是数据交换的缓冲区，是一种用于临时存储数据的高效存储机制，其主要目的是加快访问速度、减轻后台系统压力，从而提升整体性能。我们平时说的缓存大多是指内存。目的是把读写速度慢的介质的数据保存在读写速度快的介质中（这里的“快”与“慢”是相对概念），从而提高读写速度，减少时间消耗。例如：</p><ul><li><strong>CPU 高速缓存</strong>：高速缓存的读写速度远高于内存。CPU 读数据时，如果在高速缓存中找到所需数据，就不需要读内存；写数据时，可先写到高速缓存，再写回内存。</li><li><strong>磁盘缓存</strong>：磁盘缓存把常用的磁盘数据保存在内存中，内存读写速度远高于磁盘。读数据时从内存中读取；写数据时，可先写回内存，定时或定量写回到磁盘，或者同步写回。</li></ul><hr><h4 id=2-请说说有哪些缓存算法是否能手写一下-lru-代码的实现><a class=header-anchor href=#2-%e8%af%b7%e8%af%b4%e8%af%b4%e6%9c%89%e5%93%aa%e4%ba%9b%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95%e6%98%af%e5%90%a6%e8%83%bd%e6%89%8b%e5%86%99%e4%b8%80%e4%b8%8b-lru-%e4%bb%a3%e7%a0%81%e7%9a%84%e5%ae%9e%e7%8e%b0></a>2. 请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？</h4><p><strong>答</strong>：常见的缓存算法包括：</p><ul><li>FIFO（先进先出）</li><li>LRU（最近最少使用）</li><li>LFU（最不经常使用）</li><li>ARC（自适应替换）</li></ul><p><strong>LRU 代码实现</strong>（Go 语言）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;container/list&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>CacheNode</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>key</span><span class=w>   </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>value</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>LRUCache</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>capacity</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cacheList</span><span class=w> </span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>List</span><span class=w>          </span><span class=c1>// 双向链表，存储缓存数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cacheMap</span><span class=w>  </span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>Element</span><span class=w> </span><span class=c1>// 哈希表，存储键和对应在双向链表中的元素指针</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>NewLRUCache</span><span class=p>(</span><span class=nx>capacity</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>LRUCache</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=nx>LRUCache</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>capacity</span><span class=p>:</span><span class=w>  </span><span class=nx>capacity</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>cacheList</span><span class=p>:</span><span class=w> </span><span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>cacheMap</span><span class=p>:</span><span class=w>  </span><span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=o>*</span><span class=nx>list</span><span class=p>.</span><span class=nx>Element</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>cache</span><span class=w> </span><span class=o>*</span><span class=nx>LRUCache</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>element</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheMap</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=c1>// 未找到</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将访问的节点移动到双向链表的头部</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheList</span><span class=p>.</span><span class=nf>MoveToFront</span><span class=p>(</span><span class=nx>element</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>element</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>CacheNode</span><span class=p>).</span><span class=nx>value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>cache</span><span class=w> </span><span class=o>*</span><span class=nx>LRUCache</span><span class=p>)</span><span class=w> </span><span class=nf>Put</span><span class=p>(</span><span class=nx>key</span><span class=w> </span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>element</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheMap</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 如果键已存在，更新值，并移动到双向链表头部</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>element</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>CacheNode</span><span class=p>).</span><span class=nx>value</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheList</span><span class=p>.</span><span class=nf>MoveToFront</span><span class=p>(</span><span class=nx>element</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheMap</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>cache</span><span class=p>.</span><span class=nx>capacity</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 如果缓存已满，移除双向链表的尾节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>back</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheList</span><span class=p>.</span><span class=nf>Back</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>back</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>delete</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheMap</span><span class=p>,</span><span class=w> </span><span class=nx>back</span><span class=p>.</span><span class=nx>Value</span><span class=p>.(</span><span class=o>*</span><span class=nx>CacheNode</span><span class=p>).</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheList</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>back</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 添加新节点到双向链表的头部</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>node</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>CacheNode</span><span class=p>{</span><span class=nx>key</span><span class=p>:</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>value</span><span class=p>:</span><span class=w> </span><span class=nx>value</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>element</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheList</span><span class=p>.</span><span class=nf>PushFront</span><span class=p>(</span><span class=nx>node</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nx>cacheMap</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>element</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>NewLRUCache</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span><span class=w> </span><span class=c1>// 返回 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>           </span><span class=c1>// 淘汰键 2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span><span class=w> </span><span class=c1>// 返回 -1 (未找到)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>cache</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>)</span><span class=w>           </span><span class=c1>// 淘汰键 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span><span class=w> </span><span class=c1>// 返回 -1 (未找到)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span><span class=w> </span><span class=c1>// 返回 3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cache</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span><span class=w> </span><span class=c1>// 返回 4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><hr><h4 id=3-请简述一下项目整体架构举个例子说明下数据流转过程><a class=header-anchor href=#3-%e8%af%b7%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b%e9%a1%b9%e7%9b%ae%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90%e8%af%b4%e6%98%8e%e4%b8%8b%e6%95%b0%e6%8d%ae%e6%b5%81%e8%bd%ac%e8%bf%87%e7%a8%8b></a>3. 请简述一下项目整体架构。举个例子说明下数据流转过程。</h4><p><strong>答</strong>：核心架构主要由以下几个部分组成：</p><ol><li><strong>服务注册与发现（etcd）</strong>：所有缓存节点启动后，会将自己的服务地址注册到 etcd 集群中。同时，每个节点也会监听 etcd 中服务地址的变化，动态维护集群节点列表。</li><li><strong>节点间通信（gRPC）</strong>：节点之间使用 gRPC 进行通信，用于获取、设置和删除远程缓存数据。</li><li><strong>负载均衡（一致性哈希）</strong>：通过一致性哈希算法确定 key 应由哪个节点负责，每个节点维护一个哈希环，实现高效的负载均衡和动态扩缩容。</li><li><strong>缓存管理（Group & Cache）</strong>：<code>Group</code> 是缓存的命名空间，对外提供统一的 <code>Get/Set/Delete</code> 接口，内部管理本地缓存 <code>Cache</code> 实例和对等节点选择器 <code>PeerPicker</code>。</li><li><strong>本地缓存存储（Store）</strong>：<code>Cache</code> 模块是对底层具体缓存实现的封装，本项目支持 LRU 和 LRU2 两种淘汰策略。</li><li><strong>并发控制（SingleFlight）</strong>：防止缓存击穿，确保对于同一个 key，在同一时刻只有一个请求会去加载数据源，其他请求等待并共享结果。</li></ol><p><strong>数据流转示例</strong>：<br>客户端节点 A 发起 <code>Get("key_B")</code> 请求，而 <code>key_B</code> 的缓存数据实际存储在节点 B 上，流程如下：</p><ol><li><strong>请求入口</strong>：节点 A 调用 <code>group.Get(ctx, "key_B")</code>。</li><li><strong>本地缓存查询</strong>：<code>group.Get</code> 先查询本地缓存 <code>mainCache</code>，未命中。</li><li><strong>选择对等节点</strong>：调用 <code>peers.PickPeer("key_B")</code>，通过一致性哈希确定应由节点 B 负责，返回节点 B 的 gRPC 客户端。</li><li><strong>远程 gRPC 调用</strong>：节点 A 向节点 B 发起 <code>Get</code> RPC 调用，包含 group 名称和 key。</li><li><strong>远程节点处理</strong>：节点 B 的 gRPC 服务器收到请求，通过 <code>GetGroup</code> 找到对应 <code>Group</code>，调用 <code>group.Get(ctx, "key_B")</code>，本地缓存命中，返回数据。</li><li><strong>返回结果</strong>：节点 A 收到响应，将数据封装为 <code>ByteView</code>，并写入本地缓存（提高后续访问速度），最终返回给调用方。</li></ol><hr><h4 id=4-项目中为什么选择使用一致性哈希它相比普通的哈希取模方式有什么优势><a class=header-anchor href=#4-%e9%a1%b9%e7%9b%ae%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9%e4%bd%bf%e7%94%a8%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e5%ae%83%e7%9b%b8%e6%af%94%e6%99%ae%e9%80%9a%e7%9a%84%e5%93%88%e5%b8%8c%e5%8f%96%e6%a8%a1%e6%96%b9%e5%bc%8f%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8a%bf></a>4. 项目中为什么选择使用一致性哈希？它相比普通的哈希取模方式有什么优势？</h4><p><strong>答</strong>：在分布式缓存中，需要决定某个 key 应该存储在哪个节点上。</p><ul><li><p><strong>普通哈希取模 <code>hash(key) % N</code></strong> 的问题：非常简单，但扩展性差。当节点数量 N 发生变化时，几乎所有 key 的映射结果都会改变，导致大量缓存失效，引发<strong>缓存雪崩</strong>，对数据库造成巨大压力。</p></li><li><p><strong>一致性哈希的优势</strong>：</p><ul><li>将节点和 key 都映射到同一个哈希环上，key 顺时针找到的第一个节点即为负责节点。</li><li>当节点增加或删除时，只影响该节点在环上与前一节点之间的那部分 key 的归属，其他 key 的映射关系保持不变。</li><li>大大降低了节点变动对整体缓存系统的影响，保证了系统的稳定性和高可用性。</li></ul></li></ul><hr><h4 id=5-你对一致性哈希的实现有什么优化么><a class=header-anchor href=#5-%e4%bd%a0%e5%af%b9%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96%e4%b9%88></a>5. 你对一致性哈希的实现有什么优化么？</h4><p><strong>答</strong>：主要有两个优化：</p><p><strong>优化一：虚拟节点</strong></p><ul><li><strong>问题</strong>：物理节点较少时，在环上分布可能不均匀，导致数据倾斜和负载不均。</li><li><strong>解决方案</strong>：为每个物理节点创建多个虚拟节点（如 <code>A-1, A-2, ..., A-k</code>），分别映射到环上。key 先找到虚拟节点，再映射回物理节点。</li><li><strong>项目实现</strong>：在 <code>addNode</code> 方法中，通过循环 <code>replicas</code> 次（默认 50）为每个节点生成多个哈希值，大幅提高分布均匀性。</li></ul><p><strong>优化二：动态负载均衡</strong></p><ul><li><strong>问题</strong>：长时间运行后，由于 key 分布或热点数据，仍可能出现负载不均。</li><li><strong>解决方案</strong>：监控每个节点的请求量，根据实际负载动态调整其虚拟节点数量。</li><li><strong>项目实现</strong>：<ol><li><strong>负载统计</strong>：<code>Get</code> 方法返回节点前，原子增加该节点的请求计数和总请求数。</li><li><strong>定时检查</strong>：<code>startBalancer</code> 定时调用 <code>checkAndRebalance</code>。</li><li><strong>均衡判断</strong>：计算平均负载，若某节点负载偏差超过阈值，触发再均衡。</li><li><strong>动态调整</strong>：负载过高则按比例减少虚拟节点，负载过低则按比例增加虚拟节点，并限制在配置范围内。</li><li><strong>更新环</strong>：通过 <code>Remove</code> 和 <code>addNode</code> 更新节点在哈希环上的虚拟节点。</li></ol></li></ul><p>这种自适应的动态负载均衡机制，使系统能更好地应对热点数据和不均匀的请求分布。</p><hr><h4 id=6-请解释一下缓存穿透缓存击穿和缓存雪崩你在项目中是如何应对这些问题的><a class=header-anchor href=#6-%e8%af%b7%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf%e5%92%8c%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9%e4%bd%a0%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e5%ba%94%e5%af%b9%e8%bf%99%e4%ba%9b%e9%97%ae%e9%a2%98%e7%9a%84></a>6. 请解释一下缓存穿透、缓存击穿和缓存雪崩，你在项目中是如何应对这些问题的？</h4><p><strong>答</strong>：</p><p><strong>1. 缓存穿透</strong></p><ul><li><strong>定义</strong>：查询一个绝对不存在的数据。由于缓存中无此数据（缓存的是已存在的数据），请求会直接打到后端数据库。恶意攻击者可利用大量不存在的 key 造成数据库压力。</li><li><strong>KamaCache 的应对</strong>：<ul><li>当前实现未直接处理，当 <code>getter</code> 返回错误时直接返回给调用方。</li><li><strong>改进方案（面试时可提）</strong>：<ol><li><strong>缓存空值</strong>：数据库查不到时，在缓存中存储一个特殊空值，并设置较短过期时间，后续查询直接命中空值，不再访问数据库。</li><li><strong>布隆过滤器</strong>：访问缓存前先用布隆过滤器快速判断 key 是否存在，若不存在则直接返回，避免对缓存和数据库的查询。</li></ol></li></ul></li></ul><p><strong>2. 缓存击穿</strong></p><ul><li><strong>定义</strong>：热点 key 在过期瞬间，大量并发请求同时访问该 key，缓存未命中，所有请求穿透到数据库，导致数据库压力剧增。</li><li><strong>KamaCache 的应对</strong>：<ul><li><strong>核心机制</strong>：<code>SingleFlight</code>。</li><li><strong>实现分析</strong>：在 <code>group.load</code> 方法中，所有数据加载逻辑都被包裹在 <code>g.loader.Do()</code> 中。<code>singleflight.Group</code> 保证对于同一个 key，只有一个请求执行实际的加载操作，其他请求等待并共享结果。</li><li><strong>效果</strong>：即使成千上万个请求同时访问一个刚过期的热点 key，最终也只有一个请求去执行 <code>loadData</code>，有效防止数据库被冲击。</li></ul></li></ul><p><strong>3. 缓存雪崩</strong></p><ul><li><strong>定义</strong>：某一瞬间大量 key 同时过期，或缓存服务自身宕机，导致海量请求涌向数据库，造成数据库崩溃。</li><li><strong>KamaCache 的应对</strong>：<ul><li><strong>针对大量 key 同时过期</strong>：<ul><li>现有机制：<code>WithExpiration</code> 可为 <code>Group</code> 内的所有 key 设置统一过期时间，可在设置时引入随机扰动（Jitter），避免集中失效。</li></ul></li><li><strong>针对缓存服务宕机</strong>：<ul><li><strong>高可用架构</strong>：KamaCache 是分布式系统，单个节点宕机不会导致整个缓存服务不可用。</li><li><strong>一致性哈希</strong>：宕机节点从 etcd 租约过期被移除后，只有该节点负责的 key 会失效并重新映射到其他节点，其他节点缓存不受影响，大大降低了单点故障的影响范围。</li></ul></li></ul></li></ul><hr><h4 id=7-singleflight-的实现中为什么使用-syncmap-而不是-map--syncrwmutex它们的适用场景有什么不同><a class=header-anchor href=#7-singleflight-%e7%9a%84%e5%ae%9e%e7%8e%b0%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8-syncmap-%e8%80%8c%e4%b8%8d%e6%98%af-map--syncrwmutex%e5%ae%83%e4%bb%ac%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c></a>7. <code>singleflight</code> 的实现中为什么使用 <code>sync.Map</code> 而不是 <code>map + sync.RWMutex</code>？它们的适用场景有什么不同？</h4><p><strong>答</strong>：</p><ul><li><p><strong><code>map + sync.RWMutex</code></strong>：</p><ul><li><strong>工作方式</strong>：一个互斥锁（或读写锁）保护原生 map，所有读写操作必须先获取锁。</li><li><strong>性能</strong>：并发竞争激烈时，锁会成为瓶颈。写锁会阻塞所有其他读锁和写锁，导致 goroutine 串行执行。</li><li><strong>适用场景</strong>：写多读少或读写均衡，以及对 map 有复杂操作（如遍历、取长度）的场景。</li></ul></li><li><p><strong><code>sync.Map</code></strong>：</p><ul><li><strong>工作方式</strong>：内部优化为两个 map——<code>read map</code>（原子操作访问）和 <code>dirty map</code>（加锁访问）。读操作优先无锁从 <code>read map</code> 读取，写操作加锁写入 <code>dirty map</code>，删除通过标记懒删除。</li><li><strong>性能</strong>：在“读多写少”且“key 相对稳定”的场景下性能极高，大部分读操作是无锁的原子操作。</li><li><strong>适用场景</strong>：官方定义为“读多写少”和“多个 goroutine 并发读写一个固定的、很少变更的 key 集合”。</li></ul></li></ul><p><strong>在 <code>singleflight</code> 中的选择</strong>：</p><ul><li><code>Do</code> 方法中，一个 key 的生命周期是：<code>Store</code>（第一个请求到来）→ 若干次 <code>Load</code>（后续请求）→ <code>Delete</code>（fn 执行完毕）。</li><li>当第一个 goroutine 正在执行 fn 时，可能有大量并发请求来 <code>Load</code> 同一个 key。此时 <code>sync.Map</code> 的无锁读取优势明显，允许多个 goroutine 同时高效获取等待对象；而 <code>map+RWMutex</code> 虽然可并发读，但仍有锁开销，且可能被其他 key 的写操作短暂阻塞。</li><li>因此 <code>sync.Map</code> 更适合此场景。</li></ul><hr><h4 id=8-请简述-lru-算法的原理你这里的-lru2-相比普通-lru-有什么优势><a class=header-anchor href=#8-%e8%af%b7%e7%ae%80%e8%bf%b0-lru-%e7%ae%97%e6%b3%95%e7%9a%84%e5%8e%9f%e7%90%86%e4%bd%a0%e8%bf%99%e9%87%8c%e7%9a%84-lru2-%e7%9b%b8%e6%af%94%e6%99%ae%e9%80%9a-lru-%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8a%bf></a>8. 请简述 LRU 算法的原理，你这里的 LRU2 相比普通 LRU 有什么优势？</h4><p><strong>答</strong>：</p><p><strong>1. LRU</strong></p><ul><li><strong>原理</strong>：最近最少使用，认为最近访问过的数据将来被访问的概率更高。</li><li><strong>实现</strong>：哈希表 + 双向链表。哈希表 O(1) 查找，链表维护访问顺序，头部为最近使用，尾部为最近最少使用。</li><li><strong>操作</strong>：<ul><li><code>Get</code>：将节点移动到链表头部。</li><li><code>Set</code>：新节点插入头部，若缓存满则淘汰尾部节点。</li></ul></li></ul><p><strong>2. LRU2（KamaCache 实现）</strong></p><ul><li><strong>设计思想</strong>：<ul><li><strong>分桶/分段</strong>：通过哈希分桶降低锁粒度，提高并发性能。</li><li><strong>两级缓存（L1/L2）</strong>：<ul><li>新数据先放入一级缓存（L1）。</li><li>数据在 L1 被 <code>Get</code> 时，晋升到二级缓存（L2）。</li><li>L2 是真正的 LRU 缓存，淘汰策略为常规 LRU。</li></ul></li></ul></li><li><strong>相比普通 LRU 的优势</strong>：<ul><li><strong>更高并发</strong>：分桶机制显著减少锁冲突，提升吞吐量。</li><li><strong>更强抗污染能力</strong>：只有被访问至少两次的数据才会进入 L2，偶然的、单次访问的冷数据只在 L1 短暂停留，不会污染热点数据所在的 L2，使缓存命中率更稳定高效。</li></ul></li></ul><hr><h4 id=9-使用-etcd-做服务注册时有租约机制请解释一下租约的作用是什么如果某个缓存节点突然宕机整个集群是如何感知到这个变化并调整工作状态的><a class=header-anchor href=#9-%e4%bd%bf%e7%94%a8-etcd-%e5%81%9a%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c%e6%97%b6%e6%9c%89%e7%a7%9f%e7%ba%a6%e6%9c%ba%e5%88%b6%e8%af%b7%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e7%a7%9f%e7%ba%a6%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88%e5%a6%82%e6%9e%9c%e6%9f%90%e4%b8%aa%e7%bc%93%e5%ad%98%e8%8a%82%e7%82%b9%e7%aa%81%e7%84%b6%e5%ae%95%e6%9c%ba%e6%95%b4%e4%b8%aa%e9%9b%86%e7%be%a4%e6%98%af%e5%a6%82%e4%bd%95%e6%84%9f%e7%9f%a5%e5%88%b0%e8%bf%99%e4%b8%aa%e5%8f%98%e5%8c%96%e5%b9%b6%e8%b0%83%e6%95%b4%e5%b7%a5%e4%bd%9c%e7%8a%b6%e6%80%81%e7%9a%84></a>9. 使用 etcd 做服务注册时有租约机制，请解释一下租约的作用是什么？如果某个缓存节点突然宕机，整个集群是如何感知到这个变化并调整工作状态的？</h4><p><strong>答</strong>：</p><p><strong>1. 租约（Lease）的作用</strong></p><ul><li>租约是 etcd 提供的一种有时效性的契约。服务实例启动时创建一个租约，指定 TTL，并将注册的 K-V 数据与租约绑定。</li><li>服务实例通过 <code>KeepAlive</code> 定期为租约续期。只要实例存活且网络正常，租约就不会过期。</li><li><strong>核心作用</strong>：将服务实例的存活状态与其在 etcd 中注册的数据的生命周期绑定。若实例宕机或网络中断，无法续约，租约过期后 etcd 会自动删除该租约及绑定的 K-V 数据，实现自动的故障检测与清理。</li></ul><p><strong>2. 节点宕机后的感知与调整流程</strong></p><ol><li><strong>节点宕机</strong>：节点 C 崩溃，无法为租约续期。</li><li><strong>租约过期</strong>：等待一个租约周期后，租约过期。</li><li><strong>etcd 自动删除 Key</strong>：etcd 检测到租约过期，删除与该租约绑定的键。</li><li><strong>其他节点感知变化（Watch机制）</strong>：<ul><li>其他健康节点（如 A、B）通过 <code>Watch</code> 监听 <code>/services/kama-cache</code> 目录，收到 <code>EventTypeDelete</code> 事件。</li></ul></li><li><strong>集群状态调整</strong>：<ul><li>节点 A、B 从自己的对等节点列表和一致性哈希环中移除节点 C 的地址及对应客户端。</li></ul></li><li><strong>负载重新分配</strong>：<ul><li>后续请求中，原先应由节点 C 负责的 key，在哈希环上会自动顺时针找到下一个可用节点，负载平滑转移到其他节点，系统继续对外服务。</li></ul></li></ol><hr><h4 id=10-项目选择了-grpc-作为节点间的通信协议相比于更常见的-restful-apigrpc-和-protobuf-有哪些优势><a class=header-anchor href=#10-%e9%a1%b9%e7%9b%ae%e9%80%89%e6%8b%a9%e4%ba%86-grpc-%e4%bd%9c%e4%b8%ba%e8%8a%82%e7%82%b9%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae%e7%9b%b8%e6%af%94%e4%ba%8e%e6%9b%b4%e5%b8%b8%e8%a7%81%e7%9a%84-restful-apigrpc-%e5%92%8c-protobuf-%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8a%bf></a>10. 项目选择了 gRPC 作为节点间的通信协议，相比于更常见的 RESTful API，gRPC 和 Protobuf 有哪些优势？</h4><p><strong>答</strong>：</p><ul><li><p><strong>性能优势</strong>：</p><ul><li><strong>传输协议</strong>：gRPC 基于 HTTP/2，支持多路复用（Multiplexing），单个 TCP 连接可并行处理多个请求和响应，减少连接开销，解决 HTTP/1.1 的队头阻塞问题。</li><li><strong>序列化</strong>：默认使用 Protocol Buffers（Protobuf），二进制格式，体积小、编解码速度快，显著降低网络带宽消耗和 CPU 使用率。</li></ul></li><li><p><strong>服务定义与契约</strong>：</p><ul><li>使用 <code>.proto</code> 文件严格定义服务接口、方法和消息体，作为服务提供方与消费方的“契约”。</li><li>通过 <code>protoc</code> 编译器自动生成多语言的客户端存根和服务端骨架代码，保证接口一致性，减少联调成本。</li></ul></li><li><p><strong>高级特性</strong>：</p><ul><li>gRPC 原生支持四种通信模式：一元 RPC、服务端流、客户端流、双向流，为复杂业务场景提供更多可能。</li></ul></li></ul><hr><h4 id=11-缓存的并发安全需要锁或原子操作来保证解释一下互斥锁mutex和原子操作atomic的区别以及它们各自的适用场景><a class=header-anchor href=#11-%e7%bc%93%e5%ad%98%e7%9a%84%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e9%9c%80%e8%a6%81%e9%94%81%e6%88%96%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e6%9d%a5%e4%bf%9d%e8%af%81%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e4%ba%92%e6%96%a5%e9%94%81mutex%e5%92%8c%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9catomic%e7%9a%84%e5%8c%ba%e5%88%ab%e4%bb%a5%e5%8f%8a%e5%ae%83%e4%bb%ac%e5%90%84%e8%87%aa%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af></a>11. 缓存的并发安全需要锁或原子操作来保证，解释一下互斥锁（Mutex）和原子操作（Atomic）的区别，以及它们各自的适用场景。</h4><p><strong>答</strong>：</p><ul><li><p><strong>互斥锁（Mutex / RWMutex）</strong>：</p><ul><li><strong>机制</strong>：高层次的并发原语，通过操作系统锁机制保证同一时刻只有一个 goroutine 进入临界区。RWMutex 允许多个读并发，写操作完全排他。</li><li><strong>开销</strong>：锁操作通常涉及内核态与用户态切换，高并发竞争时开销较大。</li><li><strong>适用场景</strong>：保护复杂数据结构（如 map、slice、struct 多个字段）或需要执行多步复合操作的场景。</li></ul></li><li><p><strong>原子操作（Atomic）</strong>：</p><ul><li><strong>机制</strong>：低层次、无锁的并发原语，由 CPU 硬件指令直接支持，保证对单个“机器字”（如 int32、int64、pointer）的操作是原子性的。</li><li><strong>开销</strong>：比互斥锁快得多，不涉及操作系统锁。</li><li><strong>适用场景</strong>：仅适用于对单个变量进行简单的、独立的读、写、增减等操作。</li></ul></li></ul><p><strong>KamaCache 中的使用</strong>：</p><ul><li><code>mu</code> 主要保护 <code>c.store</code>，即底层缓存实现（LRU 或 LRU2），这些实现包含复杂数据结构（map、list），必须使用互斥锁保证复合操作的完整性。</li><li>对简单的状态标志和计数器（如 <code>closed</code>、<code>loads</code>、<code>hits</code>）则采用原子操作，以获得更高性能。</li></ul><hr><h4 id=12-谈谈你对-cap-理论的理解etcd-是如何做取舍的><a class=header-anchor href=#12-%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9-cap-%e7%90%86%e8%ae%ba%e7%9a%84%e7%90%86%e8%a7%a3etcd-%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%8f%96%e8%88%8d%e7%9a%84></a>12. 谈谈你对 CAP 理论的理解，etcd 是如何做取舍的？</h4><p><strong>答</strong>：<br>CAP 理论是分布式系统设计的基石，指出一个分布式系统无法同时满足以下三个核心需求，最多满足其中两个：</p><ul><li><strong>C - 一致性</strong>：所有节点在同一时刻看到的数据完全一致。</li><li><strong>A - 可用性</strong>：任何来自客户端的请求，集群中的每个节点都能在有限时间内给出响应（不保证数据最新）。</li><li><strong>P - 分区容错性</strong>：当网络发生故障（网络分区）时，系统仍能继续运行。</li></ul><p>在分布式系统中，网络故障是常态，因此 <strong>P</strong> 是必须保证的，实际选择是在 <strong>C</strong> 和 <strong>A</strong> 之间权衡。</p><p><strong>etcd 的选择</strong>：<strong>CP</strong>（放弃可用性，保证一致性）。<br>etcd 作为服务发现和配置中心，数据的正确性和一致性是核心使命。在网络分区发生时，etcd 宁愿暂时无法写入，也要保证所有节点间的强一致性，避免出现数据歧义（例如对“谁是主节点”的认知不一致）。</p><hr><h4 id=13-etcd-如何保证的一致性介绍下它使用的协议><a class=header-anchor href=#13-etcd-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e4%bb%8b%e7%bb%8d%e4%b8%8b%e5%ae%83%e4%bd%bf%e7%94%a8%e7%9a%84%e5%8d%8f%e8%ae%ae></a>13. etcd 如何保证的一致性？介绍下它使用的协议。</h4><p><strong>答</strong>：<br>etcd 使用 <strong>Raft 算法</strong>作为一致性协议。Raft 是一种易于理解和实现的共识算法，用于管理复制日志（replicated log），确保集群中所有节点对日志内容和顺序达成一致。</p><p><strong>Raft 的核心子问题</strong>：</p><ol><li><strong>领导者选举</strong>（Leader Election）</li><li><strong>日志复制</strong>（Log Replication）</li><li><strong>安全性</strong>（Safety）</li></ol><p><strong>工作流程简述</strong>：</p><ul><li><strong>角色</strong>：Raft 集群中的节点有三种角色——<strong>Leader</strong>（领导者）、<strong>Follower</strong>（跟随者）、<strong>Candidate</strong>（候选人）。</li><li><strong>领导者选举</strong>：<ul><li>启动时所有节点为 Follower，每个 Follower 拥有随机的选举计时器。</li><li>计时器超时未收到 Leader 心跳，Follower 转变为 Candidate，增加任期号并向其他节点请求投票。</li><li>获得超过半数投票的 Candidate 成为新的 Leader。</li></ul></li><li><strong>日志复制</strong>（正常工作状态）：<ul><li>所有写请求由 Leader 处理，Leader 将请求作为新日志条目附加到自己的日志中。</li><li>Leader 并行向所有 Follower 发送 <code>AppendEntries</code> RPC，要求复制该日志条目。</li><li>当 Leader 收到超过半数 Follower 成功复制的响应后，该日志条目被标记为“已提交”，Leader 将操作应用到状态机，并向客户端返回成功。</li></ul></li><li><strong>安全性</strong>：Raft 通过选举限制、日志匹配等规则，保证已提交的日志条目永远不会被覆盖或删除，确保数据一致性。</li></ul></div><footer class=article-footer><ul class=article-category-list></ul><ul class=article-tag-list itemprop=keywords></ul></footer></div><nav id=article-nav aria-label="Article navigation" data-aos=fade-up><div class="article-nav-link-wrap right"><img data-src=/images/elaina-backfront1-1.jpeg data-sizes=auto alt=GoHttp库 class=lazyload><a href=/post/gohttpv1/ aria-label=后一篇:GoHttp库 title=后一篇:GoHttp库></a><div class=article-nav-caption>后一篇</div><h3 class=article-nav-title>GoHttp库</h3></div></nav></article></section></div><footer id=footer aria-label="Site footer"><div style=width:100%;overflow:hidden><div class=footer-line></div></div><div id=footer-info><div><span class=icon-copyright></span>2026<span class="footer-info-sep rotate"></span>Elari39</div></div></footer><div class=sidebar-top><div class="sidebar-top-taichi rotate"></div><div class=arrow-up></div></div><div id=mask class=hide></div></div><nav id=mobile-nav aria-label="Mobile navigation"><div class=sidebar-wrap><div class=sidebar-toc-sidebar><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><a href=#基础要求>基础要求</a></li><li><a href=#循序渐进的学习顺序>循序渐进的学习顺序</a></li><li><a href=#代码阅读方式>代码阅读方式</a></li></ul><ul><li><a href=#什么是缓存>什么是缓存</a></li><li><a href=#为什么要实现缓存系统>为什么要实现缓存系统</a></li><li><a href=#在什么地方加缓存>在什么地方加缓存</a></li><li><a href=#本地缓存local-cache>本地缓存（Local Cache）</a><ul><li><a href=#优势>优势</a></li><li><a href=#劣势>劣势</a></li><li><a href=#本地缓存的适用场景>本地缓存的适用场景</a></li></ul></li><li><a href=#分布式缓存distributed-cache>分布式缓存（Distributed Cache）</a><ul><li><a href=#优势-1>优势</a></li><li><a href=#劣势-1>劣势</a></li><li><a href=#分布式缓存的适用场景>分布式缓存的适用场景</a></li></ul></li><li><a href=#多级缓存two-level-cache>多级缓存（Two-Level Cache）</a><ul><li><a href=#多级缓存的工作流程>多级缓存的工作流程</a></li><li><a href=#多级缓存一致性挑战>多级缓存一致性挑战</a></li></ul></li><li><a href=#做完本项目你的收获>做完本项目你的收获</a></li></ul><ul><li><a href=#整体架构>整体架构</a></li><li><a href=#核心组件及其关系>核心组件及其关系</a><ul><li><a href=#数据存储层>数据存储层</a></li><li><a href=#缓存核心层>缓存核心层</a></li><li><a href=#分布式协调层>分布式协调层</a></li><li><a href=#网络通信层>网络通信层</a></li></ul></li><li><a href=#设计模式与最佳实践>设计模式与最佳实践</a><ul><li><a href=#使用的设计模式>使用的设计模式</a></li><li><a href=#性能优化技巧>性能优化技巧</a></li><li><a href=#扩展性设计>扩展性设计</a></li></ul></li></ul><ul><li><a href=#1-安装>1. 安装</a></li><li><a href=#2-启动-etcd>2. 启动 etcd</a></li><li><a href=#3-运行示例>3. 运行示例</a><ul><li><a href=#4-多节点部署>4. 多节点部署</a></li></ul></li></ul><ul><li><a href=#核心结构设计>核心结构设计</a><ul><li><a href=#全局缓存组管理>全局缓存组管理</a></li><li><a href=#数据加载接口>数据加载接口</a></li><li><a href=#缓存组结构>缓存组结构</a></li></ul></li><li><a href=#核心功能实现>核心功能实现</a><ul><li><a href=#数据获取>数据获取</a></li><li><a href=#数据加载>数据加载</a></li><li><a href=#数据设置>数据设置</a></li><li><a href=#分布式操作同步>分布式操作同步</a></li></ul></li><li><a href=#功能特定分析>功能特定分析</a><ul><li><a href=#多级缓存架构>多级缓存架构</a></li><li><a href=#防止击穿>防止击穿</a></li></ul></li></ul><ul><li><a href=#最近最少使用lru>最近最少使用（LRU）</a><ul><li><a href=#算法原理>算法原理</a></li><li><a href=#实现方式>实现方式</a></li><li><a href=#优缺点>优缺点</a></li><li><a href=#kamacache-的实现>KamaCache 的实现</a></li></ul></li><li><a href=#lru-kleast-recently-used-k>LRU-K（Least Recently Used K）</a><ul><li><a href=#算法原理-1>算法原理</a></li><li><a href=#实现方式-1>实现方式</a></li><li><a href=#优缺点-1>优缺点</a></li></ul></li><li><a href=#lru-2least-recently-used-2>LRU-2（Least Recently Used 2）</a><ul><li><a href=#算法原理-2>算法原理</a></li><li><a href=#实现方式-2>实现方式</a></li><li><a href=#优缺点-2>优缺点</a></li><li><a href=#kamacache-的实现-1>KamaCache 的实现</a></li></ul></li><li><a href=#最少使用频率lfu>最少使用频率（LFU）</a><ul><li><a href=#算法原理-3>算法原理</a></li><li><a href=#实现方式-3>实现方式</a></li><li><a href=#优缺点-3>优缺点</a></li></ul></li></ul><ul><li><a href=#缓存击穿cache-breakdown>缓存击穿（Cache Breakdown）</a></li><li><a href=#缓存雪崩cache-avalanche>缓存雪崩（Cache Avalanche）</a></li><li><a href=#缓存穿透cache-penetration>缓存穿透（Cache Penetration）</a></li><li><a href=#singleflight-1>SingleFlight</a><ul><li><a href=#核心数据结构>核心数据结构</a></li><li><a href=#实现>实现</a></li></ul></li></ul><ul><li><a href=#为什么需要一致性哈希>为什么需要一致性哈希？</a><ul><li><a href=#节点数量变化了怎么办>节点数量变化了怎么办？</a></li><li><a href=#算法原理-4>算法原理</a></li><li><a href=#步骤>步骤</a></li><li><a href=#数据倾斜问题>数据倾斜问题</a></li></ul></li><li><a href=#kamacache-实现>KamaCache 实现</a><ul><li></li></ul></li><li><a href=#一致性哈希是分布式算法吗>一致性哈希是分布式算法吗？</a><ul><li><a href=#与-redis-的不同之处>与 Redis 的不同之处</a></li><li><a href=#适用于哪些场景>适用于哪些场景？</a></li></ul></li></ul><ul><li><a href=#服务端模块>服务端模块</a><ul><li><a href=#核心结构设计-1>核心结构设计</a></li><li><a href=#服务创建和生命周期管理>服务创建和生命周期管理</a></li><li><a href=#缓存操作接口>缓存操作接口</a></li></ul></li><li><a href=#节点选择器>节点选择器</a><ul><li><a href=#核心接口设计>核心接口设计</a></li><li><a href=#服务发现与节点管理>服务发现与节点管理</a></li><li><a href=#一致性哈希与节点选择>一致性哈希与节点选择</a></li></ul></li></ul><ul><li><a href=#项目分布式缓存系统-lcache>项目：分布式缓存系统 LCache</a></li></ul><ul><li><ul><li></li></ul></li></ul></nav></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Elari39 class=lazyload><div class=sidebar-author-name>Elari39</div><div class=sidebar-description>请别在意。
我是旅人，得继续旅行才行…</div></div><div class=sidebar-state><div class=sidebar-state-article><div>文章</div><div class=sidebar-state-number>3</div></div><a class=sidebar-state-category href=/categories/ aria-label=sidebar-state-category-link><div>分类</div><div class=sidebar-state-number>1</div></a><a class=sidebar-state-tag href=/tags/ aria-label=sidebar-state-tag-link><div>标签</div><div class=sidebar-state-number>1</div></a></div><div class=sidebar-social><div class="icon-email sidebar-social-icon"><a href=mailto:majo_elaina@qq.com itemprop=url target=_blank aria-label=email rel="noopener nofollow noreferrer"></a></div><div class="icon-github sidebar-social-icon"><a href=https://github.com/Elari39 itemprop=url target=_blank aria-label=github rel="noopener nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=首页></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>首页</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=归档></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>归档</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=关于></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>关于</div></div></div></div></div><div class=sidebar-btn-wrapper><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></nav></div><script src=https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js integrity=sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf+e crossorigin=anonymous></script><script src=https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js integrity=sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q crossorigin=anonymous></script><script src=/js/main.js integrity crossorigin=anonymous></script><script src=/js/aos.js integrity crossorigin=anonymous></script><script>var aosInit=()=>{AOS.init({duration:1e3,easing:"ease",once:!0,offset:50})};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",aosInit):aosInit()</script><script src=/js/pjax_main.js integrity crossorigin=anonymous data-pjax></script><script>var setupFirework=()=>{if((!!1||!window.matchMedia("(max-width: 768px)").matches)&&window.firework){const e=JSON.parse('{"excludeelements":["a","button"],"particles":[{"colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["emit"],"number":20,"shape":"circle","shapeOptions":{"alpha":[0.3,0.5],"radius":[16,32]}},{"colors":["var(--red-0)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["diffuse"],"number":1,"shape":"circle","shapeOptions":{"alpha":[0.2,0.5],"lineWidth":6,"radius":20}}]}');e.excludeElements=e.excludeelements,delete e.excludeelements,window.firework(e)}}</script><script src=https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js defer onload=setupFirework() integrity=sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8+pUoWX8n1rgq282T crossorigin=anonymous></script><div id=lazy-script><div><script data-pjax>window.REIMU_POST={author:"Elari39",title:"GoCache 学习建议",url:"https://Elari39.github.io/post/gocache/",description:` 学习建议 完成项目指导时间
如果具备【基础要求】里的基础，每天 6 小时，约 7 天完成。 如果边学边做，每天 6~8 小时，约 15 天完成。 代码量
2000 行左右（除去测试代码）
基础要求 Go 语言基础：goroutine、channel、接口等核心概念 缓存原理：缓存淘汰策略（LRU、LFU 等） 网络编程：gRPC 基础、HTTP 协议、TCP/IP 循序渐进的学习顺序 从单机缓存开始
先理解 ByteView、lruCache 等核心数据结构 熟悉 Cache 和基本的缓存操作 理解分组缓存
学习 Group 结构及其工作原理 掌握缓存加载、过期策略等机制 研究分布式扩展
一 …`,cover:"https://Elari39.github.io/post/gocache/gocache.jpg"}</script><script src=/js/insert_highlight.js integrity crossorigin=anonymous data-pjax></script><script src=/js/tabs.js integrity crossorigin=anonymous data-pjax defer></script><script type=module data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
        }
        pswp()
      </script></div></div><script>"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()})</script><script>const reimuCopyright=String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;console.log(String.raw`%c ${reimuCopyright}`,"color: #ff5252;"),console.log("%c Theme.Reimu %c https://github.com/D-Sketon/hugo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script></body></html>