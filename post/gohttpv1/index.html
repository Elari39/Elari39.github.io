<!doctype html><html lang=zh-cn data-theme-mode=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>GoHttp库 | Elari39</title><meta name=description content="Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。"><script>window.siteConfig=JSON.parse('{"anchor_icon":null,"base":"https://Elari39.github.io/","clipboard":{"copyright":{"count":50,"enable":false,"license_type":"by-nc-sa"},"fail":{"en":"Copy failed (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-br":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ","zh-cn":"复制失败 (ﾟ⊿ﾟ)ﾂ","zh-tw":"複製失敗 (ﾟ⊿ﾟ)ﾂ"},"success":{"en":"Copy successfully (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-br":"Copiado com sucesso (*^▽^*)","zh-cn":"复制成功 (*^▽^*)","zh-tw":"複製成功 (*^▽^*)"}},"code_block":{"expand":true},"icon_font":"4552607_4k4bc36ef96","outdate":{"daysago":180,"enable":false,"message":{"en":"This article was last updated on {time}. Please note that the content may no longer be applicable.","ja":"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。","pt-br":"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.","zh-cn":"本文最后更新于 {time}，请注意文中内容可能已不适用。","zh-tw":"本文最後更新於 {time}，請注意文中內容可能已不適用。"}}}')</script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap" media=print onload='this.media="all"'><link rel=preload href=//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=stylesheet href=/css/loader.min.ac746e154f756f8220326eeb52a719f142ab038be5a8ddf30ea5ef15ef2356ea.css><meta property="og:type" content="website"><meta property="og:title" content="GoHttp库 | Elari39"><meta property="og:description" content="Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。"><meta property="og:url" content="https://Elari39.github.io/post/gohttpv1/"><meta property="og:site_name" content="Elari的博客"><meta property="og:image" content="/"><meta property="article:author" content="Elari39"><meta property="article:published_time" content="2026-02-14T17:01:00+00:00"><meta property="article:modified_time" content="2026-02-14T17:01:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:image content="/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.d356b9fcdcb0a64f094049c52fdb5d1cf4326130f6ff2847fce56c677e820ff0.css><link rel=preload as=style href=https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css integrity=sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx/1oA/0l8ysE crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css integrity=sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz+YI crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><script src=https://npm.webcache.cn/pace-js@1.2.4/pace.min.js integrity=sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8 crossorigin=anonymous></script><link rel=stylesheet href=https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css integrity=sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa crossorigin=anonymous></head><body><div id=loader><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class=spinner-box><div class="loading-taichi rotate"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" shape-rendering="geometricPrecision"><path d="M303.5 432a80 80 0 01-12 160 80 80 0 0112-160z" fill="var(--red-1, #ff5252)"/><path d="M512 65a447 447 0 010 894V929a417 417 0 000-834 417 417 0 000 834v30a447 447 0 010-894zm0 30A417 417 0 01929 512 208.5 208.5.0 01720.5 720.5V592a80 80 0 000-160 80 80 0 000 160V720.5A208.5 208.5.0 01512 512 208.5 208.5.0 00303.5 303.5 208.5 208.5.0 0095 512 417 417 0 01512 95z" fill="var(--red-1, #ff5252)"/></svg></div><div class=loading-word>少女祈祷中...</div></div></div></div><script>var time=null,loaderEl=document.getElementById("loader"),startLoading=()=>{time=Date.now(),loaderEl.classList.remove("loading")},hideLoader=()=>{document.body.style.overflow="auto",loader.classList.add("loading")},endLoading=()=>{time?Date.now()-time>500?(time=null,hideLoader()):(setTimeout(endLoading,500-(Date.now()-time)),time=null):hideLoader()};window.addEventListener("DOMContentLoaded",endLoading),loaderEl.addEventListener("click",endLoading)</script><div id=copy-tooltip></div><div id=lang-tooltip>本文章没有找到对应的语言版本</div><div id=heatmap-tooltip></div><div id=container><div id=wrap><div id=header-nav><nav id=main-nav aria-label="Primary navigation"><a class=main-nav-link-wrap href=/><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>首页</span>
</a><a class=main-nav-link-wrap href=/archives><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>归档</span>
</a><a class=main-nav-link-wrap href=/about><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>关于</span>
</a><a id=main-nav-toggle class=nav-icon aria-label="Toggle navigation" role=button></a></nav><nav id=sub-nav aria-label="Secondary navigation"></nav></div><header id=header aria-label="Site header"><picture></picture><img fetchpriority=high src=/images/banner.webp alt=GoHttp库><div id=header-outer><div id=header-title><span id=logo><h1 data-aos=slide-up>GoHttp库</h1></span><h2 id=subtitle-wrap data-aos=slide-down></h2></div></div></header><div id=content aria-label="Page content" class=sidebar-right><aside id=sidebar aria-label=Sidebar><div class="sidebar-wrapper-container sticky"><div class=sidebar-wrapper><div class=sidebar-wrap data-aos=fade-up><div class=sidebar-toc-sidebar style=margin-bottom:10px><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents></nav></div></div></div></div><div class=sidebar-widget></div></div></aside><section id=main aria-label="Main content"><article class="h-entry article" itemscope itemtype=https://schema.org/BlogPosting><div class=article-inner data-aos=fade-up><div class=article-meta><div class=article-date><span class="article-date-link icon-calendar" data-aos=zoom-in><time datetime="2026-02-14 17:01:00 +0000 UTC" itemprop=datePublished>2026-02-14</time>
<time style=display:none id=post-update-time>2026-02-14</time></span></div></div><div class=hr-line></div><div class="e-content article-entry" itemprop=articleBody><p>Go语言的 <code>net/http</code> 标准库功能强大，它提供了构建HTTP客户端和服务端所需的所有核心功能，并且是许多第三方Web框架的基石。理解它的工作原理，不仅能让你不依赖框架也能搭建高性能的Web服务，更能让你在使用任何Go Web框架时都心中有数。</p><p>下面，我们将从零开始，以最新版的Go（语义上无破坏性变更，仍适用）为例，详细拆解 <code>net/http</code> 库。</p><p>### 1. 开箱即用的HTTP服务端</p><p>首先，来看看如何用最少的代码启动一个Web服务。</p><p>#### 1.1 快速启动：Hello World示例</p><p>```go</p><p>package main</p><p>import (</p><p>&ldquo;fmt&rdquo;</p><p>&ldquo;log&rdquo;</p><p>&ldquo;net/http&rdquo;</p><p>)</p><p>func main() {</p><p>// 1. 注册路由：当访问根路径"/&ldquo;时，执行一个匿名函数</p><p>http.HandleFunc(&rdquo;/", func(w http.ResponseWriter, r *http.Request) {</p><p>// w 用于写入响应，r 包含了客户端请求的所有信息</p><p>fmt.Fprintf(w, &ldquo;Hello, 你访问了: %s&rdquo;, r.URL.Path)</p><p>})</p><p>// 2. 启动服务，监听在本地的8080端口</p><p>log.Println(&ldquo;服务启动在 <a href=http://localhost:8080>http://localhost:8080</a>&rdquo;)</p><p>err := http.ListenAndServe(":8080", nil)</p><p>if err != nil {</p><p>log.Fatal(&ldquo;服务启动失败: &ldquo;, err)</p><p>}</p><p>}</p><p>```</p><p>运行这段代码，在浏览器访问 <code>http://localhost:8080/anything</code><a href=http://localhost:8080/anything%60%EF%BC%8C%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E8%BE%93%E5%87%BA%E3%80%82%E8%BF%99%E8%83%8C%E5%90%8E%E5%85%B6%E5%AE%9E%E9%9A%90%E8%97%8F%E7%9D%80>，就能看到输出。这背后其实隐藏着</a> <code>net/http</code> 的几个核心设计。</p><p>#### 1.2 核心接口：`Handler`</p><p>整个 <code>net/http</code> 的基石是一个名为 <code>Handler</code> 的接口。任何东西，只要实现了它，就能处理HTTP请求。</p><p>```go</p><p>type Handler interface {</p><p>ServeHTTP(ResponseWriter, *Request)</p><p>}</p><p>```</p><p>* **`http.ResponseWriter`**：用于构建并返回HTTP响应，比如设置状态码、Header和写入响应体。</p><p>* **`*http.Request`**：包含了客户端发送的请求的所有信息，比如URL、方法（GET/POST）、Header和Body。</p><p>#### 1.3 路由与处理器：`ServeMux` 和 <code>HandlerFunc</code></p><p>那上面代码里的 <code>http.HandleFunc</code> 是怎么回事？它和 <code>Handler</code> 有什么关系？</p><p>* **`http.HandleFunc` 的本质**：这是一个"适配器&rdquo;。它接收一个普通函数（签名是 <code>func(w http.ResponseWriter, r *http.Request)</code>），然后将这个函数转换成 <code>HandlerFunc</code> 类型。而这个 <code>HandlerFunc</code> 类型，恰好实现了 <code>Handler</code> 接口的 <code>ServeHTTP</code> 方法，在其内部调用了我们传入的那个函数。</p><p>```go</p><p>type HandlerFunc func(ResponseWriter, *Request)</p><p>// HandlerFunc 自己的 ServeHTTP 方法</p><p>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</p><p>f(w, r) // 调用自身</p><p>}</p><p>```</p><p>这就是为什么普通的函数也能用来处理请求。</p><p>* **路由器 <code>ServeMux</code>**：`http.HandleFunc` 实际上是把路由规则（比如&rdquo;/"）和转换后的 <code>Handler</code> 注册到了一个默认的路由器 <code>DefaultServeMux</code> 上。`ServeMux` 本身也实现了 <code>Handler</code> 接口。它的 <code>ServeHTTP</code> 方法的核心逻辑就是：**根据请求的URL路径，找到并调用匹配的、用户注册的子Handler**。这就像一个请求分发器。</p><p>所以，`http.ListenAndServe(":8080", nil)` 的第二个参数是 <code>nil</code>，意味着使用默认的 <code>DefaultServeMux</code>。也可以创建一个自定义的 <code>ServeMux</code> 传入，实现更灵活的路由控制。</p><p>### 2. 深入服务端：源码视角的请求处理流程</p><p>当一个请求到达时，`net/http` 内部经历了一系列精妙的步骤：</p><p>1. **`ListenAndServe` 启动**：`http.ListenAndServe` 内部创建了一个 <code>Server</code> 对象，并调用其 <code>ListenAndServe</code> 方法。</p><p>2. **监听端口**：`Server` 使用 <code>net.Listen</code> 在指定地址上创建了一个网络监听器（Listener）。</p><p>3. **循环Accept**：在一个 <code>for</code> 循环中，不停地调用 <code>Listener.Accept()</code> 接受新连接。</p><p>4. **创建 goroutine**：每接受一个连接，就**启动一个新的 goroutine**（轻量级线程）来处理这个连接。这是Go语言高并发的基石。</p><p>5. **处理连接**：在新的 goroutine 中，循环读取连接上的多个请求（如果开启了Keep-Alive）。</p><p>6. **寻找 Handler**：对于每个请求，调用 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>。`serverHandler` 是一个内部包装，它的 <code>ServeHTTP</code> 方法会检查 <code>Server</code> 结构体中是否设置了 <code>Handler</code>（即我们传入的自定义路由），如果没有，就使用 <code>DefaultServeMux</code>。</p><p>7. **路由分发**：调用 <code>Handler</code>（也就是 <code>ServeMux</code>）的 <code>ServeHTTP</code> 方法。`ServeMux` 根据请求的路径，查找之前注册的路由表，找到最匹配的用户自定义 <code>Handler</code>（可能是 <code>HandlerFunc</code> 或任何实现了 <code>Handler</code> 接口的对象）。</p><p>8. **执行业务逻辑**：最后，调用找到的 <code>Handler</code> 的 <code>ServeHTTP</code> 方法，也就是执行我们写的业务代码。</p><p>这个过程清晰地展示了 <code>net/http</code> 的设计精髓：通过 <code>Handler</code> 接口实现了高度的可扩展性，通过 <code>ServeMux</code> 提供了基础的路由能力，并通过 goroutine-per-connection 模型保障了高并发性能。</p><p>### 3. 功能强大的HTTP客户端</p><p><code>net/http</code> 不仅服务端强大，其客户端功能也同样完善。</p><p>#### 3.1 基础请求：`Get`、`Post`</p><p>发起简单的HTTP请求非常直接。</p><p>```go</p><p>package main</p><p>import (</p><p>&ldquo;fmt&rdquo;</p><p>&ldquo;io/ioutil&rdquo;</p><p>&ldquo;log&rdquo;</p><p>&ldquo;net/http&rdquo;</p><p>)</p><p>func main() {</p><p>resp, err := http.Get("<a href=https://api.github.com/users/octocat>https://api.github.com/users/octocat</a>")</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>// !!! 重要：必须关闭响应体，以防止资源泄露 !!!</p><p>defer resp.Body.Close()</p><p>body, err := ioutil.ReadAll(resp.Body)</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>fmt.Printf(&ldquo;状态码: %d\n&rdquo;, resp.StatusCode)</p><p>fmt.Printf(&ldquo;响应头: %v\n&rdquo;, resp.Header)</p><p>fmt.Printf(&ldquo;响应体: %s\n&rdquo;, string(body))</p><p>}</p><p>```</p><p>类似地，还有 <code>http.Post</code> 和 <code>http.PostForm</code> 可用。</p><p>#### 3.2 高级控制：`http.Client`</p><p>对于生产级应用，直接使用 <code>http.Get</code> 是不够的，因为它使用默认的 <code>http.DefaultClient</code>，缺乏超时等关键控制。此时需要自定义 <code>http.Client</code>。</p><p>```go</p><p>client := &amp;http.Client{</p><p>// 设置超时时间，避免请求卡死</p><p>Timeout: 10 * time.Second,</p><p>// 自定义重定向策略</p><p>CheckRedirect: func(req _http.Request, via []_http.Request) error {</p><p>fmt.Println(&ldquo;重定向到:&rdquo;, req.URL)</p><p>return nil // 允许最多10次重定向</p><p>},</p><p>}</p><p>resp, err := client.Get("<a href=http://example.com>http://example.com</a>")</p><p>if err != nil {</p><p>log.Fatal(err)</p><p>}</p><p>defer resp.Body.Close()</p><p>```</p><p>#### 3.3 核心驱动：`http.Transport`</p><p><code>http.Client</code> 是外观，真正的执行者是 <code>http.Transport</code>。它负责管理连接池、TLS配置、代理等底层细节。</p><p>```go</p><p>// 自定义 Transport，优化连接池</p><p>tr := &amp;http.Transport{</p><p>MaxIdleConns: 100, // 最大空闲连接数</p><p>MaxIdleConnsPerHost: 10, // 每个Host的最大空闲连接数</p><p>IdleConnTimeout: 90 * time.Second, // 空闲连接超时时间</p><p>TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true}, // 跳过证书验证（仅示例，请勿用于生产）</p><p>}</p><p>client := &amp;http.Client{</p><p>Transport: tr,</p><p>Timeout: 5 * time.Second,</p><p>}</p><p>```</p><p>合理配置 <code>Transport</code> 可以大幅提升客户端在高并发场景下的性能。</p><p>### 4. 最佳实践与进阶技巧</p><p>#### 4.1 优雅处理请求</p><p>* **务必关闭 Body**：无论是服务端读取请求体，还是客户端读取响应体，都要确保在最后关闭 <code>Body</code>，否则会造成连接泄露。</p><p>* **使用 Context 超时控制**：对于可能耗时较长的请求，可以使用 <code>context.WithTimeout</code> 创建一个带超时的 Context，并传递给 <code>http.NewRequestWithContext</code>。当超时发生时，请求会自动取消。</p><p>#### 4.2 构建健壮的服务端</p><p>* **自定义 Server**：除了 <code>ListenAndServe</code>，更推荐显式创建 <code>http.Server</code> 对象，以便精细化配置，如读写超时、最大Header大小等，防止慢攻击。</p><p>```go</p><p>srv := &amp;http.Server{</p><p>Addr: &ldquo;:8080&rdquo;,</p><p>Handler: myHandler,</p><p>ReadTimeout: 5 * time.Second,</p><p>WriteTimeout: 10 * time.Second,</p><p>}</p><p>log.Fatal(srv.ListenAndServe())</p><p>```</p><p>* **中间件模式**：`net/http` 虽然没有内置中间件，但通过函数式编程可以轻松实现。一个中间件就是一个接收 <code>Handler</code> 并返回一个新 <code>Handler</code> 的函数。</p><p>```go</p><p>func loggingMiddleware(next http.Handler) http.Handler {</p><p>return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {</p><p>log.Printf(&ldquo;收到请求: %s %s&rdquo;, r.Method, r.URL.Path)</p><p>next.ServeHTTP(w, r) // 调用下一个处理器</p><p>log.Println(&ldquo;请求处理完毕&rdquo;)</p><p>})</p><p>}</p><p>// 使用</p><p>finalHandler := http.HandlerFunc(final)</p><p>http.Handle("/", loggingMiddleware(finalHandler))</p><p>```</p><p>#### 4.3 何时使用第三方框架？</p><p><code>net/http</code> 功能强大，但对于非常复杂的路由需求（如路径参数 <code>/users/:id</code>）、需要大量开箱即用的中间件（如JWT认证、限流）或更强大的依赖注入等场景，引入像 <code>gin</code>、`echo` 或 <code>gorilla/mux</code> 等第三方框架可以显著提升开发效率。它们的底层，无一例外，都是建立在 <code>net/http</code> 之上的。</p><p>希望这份详解能帮助你更好地理解和使用Go标准库中的这颗明珠。</p></div><footer class=article-footer><ul class=article-category-list><li class=article-tag-list-item data-aos=zoom-in><a class=article-category-link href=/categories/go data-aos=zoom-in>Go</a></li></ul><ul class=article-tag-list itemprop=keywords></ul></footer></div><nav id=article-nav aria-label="Article navigation" data-aos=fade-up><div class="article-nav-link-wrap left"><img data-src=/post/gocache/gocache.jpg data-sizes=auto alt="GoCache 学习建议" class=lazyload><a href=/post/gocache/ aria-label="前一篇:GoCache 学习建议" title="前一篇:GoCache 学习建议"></a><div class=article-nav-caption>前一篇</div><h3 class=article-nav-title>GoCache 学习建议</h3></div></nav></article></section></div><footer id=footer aria-label="Site footer"><div style=width:100%;overflow:hidden><div class=footer-line></div></div><div id=footer-info><div><span class=icon-copyright></span>2026<span class="footer-info-sep rotate"></span>Elari39</div></div></footer><div class=sidebar-top><div class="sidebar-top-taichi rotate"></div><div class=arrow-up></div></div><div id=mask class=hide></div></div><nav id=mobile-nav aria-label="Mobile navigation"><div class=sidebar-wrap><div class=sidebar-toc-sidebar><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents></nav></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Elari39 class=lazyload><div class=sidebar-author-name>Elari39</div><div class=sidebar-description>请别在意。
我是旅人，得继续旅行才行…</div></div><div class=sidebar-state><div class=sidebar-state-article><div>文章</div><div class=sidebar-state-number>2</div></div><a class=sidebar-state-category href=/categories/ aria-label=sidebar-state-category-link><div>分类</div><div class=sidebar-state-number>1</div></a><a class=sidebar-state-tag href=/tags/ aria-label=sidebar-state-tag-link><div>标签</div><div class=sidebar-state-number>0</div></a></div><div class=sidebar-social><div class="icon-email sidebar-social-icon"><a href=mailto:majo_elaina@qq.com itemprop=url target=_blank aria-label=email rel="noopener nofollow noreferrer"></a></div><div class="icon-github sidebar-social-icon"><a href=https://github.com/Elari39 itemprop=url target=_blank aria-label=github rel="noopener nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=首页></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>首页</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=归档></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>归档</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=关于></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>关于</div></div></div></div></div><div class=sidebar-btn-wrapper><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></nav></div><script src=https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js integrity=sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf+e crossorigin=anonymous></script><script src=https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js integrity=sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q crossorigin=anonymous></script><script src=/js/main.js integrity crossorigin=anonymous></script><script src=/js/aos.js integrity crossorigin=anonymous></script><script>var aosInit=()=>{AOS.init({duration:1e3,easing:"ease",once:!0,offset:50})};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",aosInit):aosInit()</script><script src=/js/pjax_main.js integrity crossorigin=anonymous data-pjax></script><script>var setupFirework=()=>{if((!!1||!window.matchMedia("(max-width: 768px)").matches)&&window.firework){const e=JSON.parse('{"excludeelements":["a","button"],"particles":[{"colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["emit"],"number":20,"shape":"circle","shapeOptions":{"alpha":[0.3,0.5],"radius":[16,32]}},{"colors":["var(--red-0)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["diffuse"],"number":1,"shape":"circle","shapeOptions":{"alpha":[0.2,0.5],"lineWidth":6,"radius":20}}]}');e.excludeElements=e.excludeelements,delete e.excludeelements,window.firework(e)}}</script><script src=https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js defer onload=setupFirework() integrity=sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8+pUoWX8n1rgq282T crossorigin=anonymous></script><div id=lazy-script><div><script data-pjax>window.REIMU_POST={author:"Elari39",title:"GoHttp库",url:"https://Elari39.github.io/post/gohttpv1/",description:"Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。",cover:"https://Elari39.github.io/images/banner.webp"}</script><script src=/js/insert_highlight.js integrity crossorigin=anonymous data-pjax></script><script src=/js/tabs.js integrity crossorigin=anonymous data-pjax defer></script><script type=module data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
        }
        pswp()
      </script></div></div><script>"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()})</script><script>const reimuCopyright=String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;console.log(String.raw`%c ${reimuCopyright}`,"color: #ff5252;"),console.log("%c Theme.Reimu %c https://github.com/D-Sketon/hugo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script></body></html>