<!doctype html><html lang=zh-cn data-theme-mode=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>GoHttp库 | Elari39</title><meta name=description content="Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。"><script>window.siteConfig=JSON.parse('{"anchor_icon":null,"base":"https://Elari39.github.io/","clipboard":{"copyright":{"count":50,"enable":false,"license_type":"by-nc-sa"},"fail":{"en":"Copy failed (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-br":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ","zh-cn":"复制失败 (ﾟ⊿ﾟ)ﾂ","zh-tw":"複製失敗 (ﾟ⊿ﾟ)ﾂ"},"success":{"en":"Copy successfully (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-br":"Copiado com sucesso (*^▽^*)","zh-cn":"复制成功 (*^▽^*)","zh-tw":"複製成功 (*^▽^*)"}},"code_block":{"expand":true},"icon_font":"4552607_4k4bc36ef96","outdate":{"daysago":180,"enable":false,"message":{"en":"This article was last updated on {time}. Please note that the content may no longer be applicable.","ja":"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。","pt-br":"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.","zh-cn":"本文最后更新于 {time}，请注意文中内容可能已不适用。","zh-tw":"本文最後更新於 {time}，請注意文中內容可能已不適用。"}}}')</script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap" media=print onload='this.media="all"'><link rel=preload href=//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=stylesheet href=/css/loader.min.ac746e154f756f8220326eeb52a719f142ab038be5a8ddf30ea5ef15ef2356ea.css><meta property="og:type" content="website"><meta property="og:title" content="GoHttp库 | Elari39"><meta property="og:description" content="Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。"><meta property="og:url" content="https://Elari39.github.io/post/gohttp/gohttpv1/"><meta property="og:site_name" content="Elari的博客"><meta property="og:image" content="/images/elaina-backfront1-1.jpeg"><meta property="article:author" content="Elari39"><meta property="article:published_time" content="2026-02-14T17:20:00+00:00"><meta property="article:modified_time" content="2026-02-14T17:20:00+00:00"><meta property="article:tag" content="Go"><meta name=twitter:card content="summary"><meta name=twitter:image content="/images/elaina-backfront1-1.jpeg"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.d356b9fcdcb0a64f094049c52fdb5d1cf4326130f6ff2847fce56c677e820ff0.css><link rel=preload as=style href=https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css integrity=sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx/1oA/0l8ysE crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css integrity=sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz+YI crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><script src=https://npm.webcache.cn/pace-js@1.2.4/pace.min.js integrity=sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8 crossorigin=anonymous></script><link rel=stylesheet href=https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css integrity=sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa crossorigin=anonymous></head><body><div id=loader><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class=spinner-box><div class="loading-taichi rotate"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" shape-rendering="geometricPrecision"><path d="M303.5 432a80 80 0 01-12 160 80 80 0 0112-160z" fill="var(--red-1, #ff5252)"/><path d="M512 65a447 447 0 010 894V929a417 417 0 000-834 417 417 0 000 834v30a447 447 0 010-894zm0 30A417 417 0 01929 512 208.5 208.5.0 01720.5 720.5V592a80 80 0 000-160 80 80 0 000 160V720.5A208.5 208.5.0 01512 512 208.5 208.5.0 00303.5 303.5 208.5 208.5.0 0095 512 417 417 0 01512 95z" fill="var(--red-1, #ff5252)"/></svg></div><div class=loading-word>少女祈祷中...</div></div></div></div><script>var time=null,loaderEl=document.getElementById("loader"),startLoading=()=>{time=Date.now(),loaderEl.classList.remove("loading")},hideLoader=()=>{document.body.style.overflow="auto",loader.classList.add("loading")},endLoading=()=>{time?Date.now()-time>500?(time=null,hideLoader()):(setTimeout(endLoading,500-(Date.now()-time)),time=null):hideLoader()};window.addEventListener("DOMContentLoaded",endLoading),loaderEl.addEventListener("click",endLoading)</script><div id=copy-tooltip></div><div id=lang-tooltip>本文章没有找到对应的语言版本</div><div id=heatmap-tooltip></div><div id=container><div id=wrap><div id=header-nav><nav id=main-nav aria-label="Primary navigation"><a class=main-nav-link-wrap href=/><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>首页</span>
</a><a class=main-nav-link-wrap href=/archives><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>归档</span>
</a><a class=main-nav-link-wrap href=/about><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>关于</span>
</a><a id=main-nav-toggle class=nav-icon aria-label="Toggle navigation" role=button></a></nav><nav id=sub-nav aria-label="Secondary navigation"></nav></div><header id=header aria-label="Site header"><picture></picture>
<img fetchpriority=high src=/images/elaina-backfront1-1.jpeg alt=GoHttp库><div id=header-outer><div id=header-title><span id=logo><h1 data-aos=slide-up>GoHttp库</h1></span><h2 id=subtitle-wrap data-aos=slide-down></h2></div></div></header><div id=content aria-label="Page content" class=sidebar-right><aside id=sidebar aria-label=Sidebar><div class="sidebar-wrapper-container sticky"><div class=sidebar-wrapper><div class=sidebar-wrap data-aos=fade-up><div class=sidebar-toc-sidebar style=margin-bottom:10px><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents></nav></div></div></div></div><div class=sidebar-widget></div></div></aside><section id=main aria-label="Main content"><article class="h-entry article" itemscope itemtype=https://schema.org/BlogPosting><div class=article-inner data-aos=fade-up><div class=article-meta><div class=article-date><span class="article-date-link icon-calendar" data-aos=zoom-in><time datetime="2026-02-14 17:20:00 +0000 UTC" itemprop=datePublished>2026-02-14</time>
<time style=display:none id=post-update-time>2026-02-14</time></span></div></div><div class=hr-line></div><div class="e-content article-entry" itemprop=articleBody><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-markdown data-lang=markdown><span style=display:flex><span>Go语言的 <span style=color:#e6db74>`net/http`</span> 标准库功能强大，它提供了构建HTTP客户端和服务端所需的所有核心功能，并且是许多第三方Web框架的基石。理解它的工作原理，不仅能让你不依赖框架也能搭建高性能的Web服务，更能让你在使用任何Go Web框架时都心中有数。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>下面，我们将从零开始，以最新版的Go（语义上无破坏性变更，仍适用）为例，详细拆解 <span style=color:#e6db74>`net/http`</span> 库。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### 1. 开箱即用的HTTP服务端
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>首先，来看看如何用最少的代码启动一个Web服务。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 1.1 快速启动：Hello World示例
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 注册路由：当访问根路径&#34;/&#34;时，执行一个匿名函数</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// w 用于写入响应，r 包含了客户端请求的所有信息</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Hello, 你访问了: %s&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 启动服务，监听在本地的8080端口</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;服务启动在 http://localhost:8080&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;服务启动失败: &#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>运行这段代码，在浏览器访问 <span style=color:#e6db74>`http://localhost:8080/anything`</span>，就能看到输出。这背后其实隐藏着 <span style=color:#e6db74>`net/http`</span> 的几个核心设计。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 1.2 核心接口：`Handler`
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>整个 <span style=color:#e6db74>`net/http`</span> 的基石是一个名为 <span style=color:#e6db74>`Handler`</span> 的接口。任何东西，只要实现了它，就能处理HTTP请求。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Handler</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **<span style=color:#e6db74>`http.ResponseWriter`</span>**：用于构建并返回HTTP响应，比如设置状态码、Header和写入响应体。
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **<span style=color:#e6db74>`*http.Request`</span>**：包含了客户端发送的请求的所有信息，比如URL、方法（GET/POST）、Header和Body。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 1.3 路由与处理器：`ServeMux` 和 `HandlerFunc`
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>那上面代码里的 <span style=color:#e6db74>`http.HandleFunc`</span> 是怎么回事？它和 <span style=color:#e6db74>`Handler`</span> 有什么关系？
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **<span style=color:#e6db74>`http.HandleFunc`</span> 的本质**：这是一个&#34;适配器&#34;。它接收一个普通函数（签名是 <span style=color:#e6db74>`func(w http.ResponseWriter, r *http.Request)`</span>），然后将这个函数转换成 <span style=color:#e6db74>`HandlerFunc`</span> 类型。而这个 <span style=color:#e6db74>`HandlerFunc`</span> 类型，恰好实现了 <span style=color:#e6db74>`Handler`</span> 接口的 <span style=color:#e6db74>`ServeHTTP`</span> 方法，在其内部调用了我们传入的那个函数。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>HandlerFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// HandlerFunc 自己的 ServeHTTP 方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>HandlerFunc</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>) <span style=color:#75715e>// 调用自身</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>这就是为什么普通的函数也能用来处理请求。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **路由器 <span style=color:#e6db74>`ServeMux`</span>**：<span style=color:#e6db74>`http.HandleFunc`</span> 实际上是把路由规则（比如&#34;/&#34;）和转换后的 <span style=color:#e6db74>`Handler`</span> 注册到了一个默认的路由器 <span style=color:#e6db74>`DefaultServeMux`</span> 上。<span style=color:#e6db74>`ServeMux`</span> 本身也实现了 <span style=color:#e6db74>`Handler`</span> 接口。它的 <span style=color:#e6db74>`ServeHTTP`</span> 方法的核心逻辑就是：**根据请求的URL路径，找到并调用匹配的、用户注册的子Handler**。这就像一个请求分发器。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>所以，<span style=color:#e6db74>`http.ListenAndServe(&#34;:8080&#34;, nil)`</span> 的第二个参数是 <span style=color:#e6db74>`nil`</span>，意味着使用默认的 <span style=color:#e6db74>`DefaultServeMux`</span>。也可以创建一个自定义的 <span style=color:#e6db74>`ServeMux`</span> 传入，实现更灵活的路由控制。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### 2. 深入服务端：源码视角的请求处理流程
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>当一个请求到达时，<span style=color:#e6db74>`net/http`</span> 内部经历了一系列精妙的步骤：
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>1.</span> <span style=font-style:italic>**</span><span style=color:#e6db74>`ListenAndServe`</span> 启动**：<span style=color:#e6db74>`http.ListenAndServe`</span> 内部创建了一个 <span style=color:#e6db74>`Server`</span> 对象，并调用其 <span style=color:#e6db74>`ListenAndServe`</span> 方法。
</span></span><span style=display:flex><span><span style=color:#66d9ef>2.</span> <span style=font-weight:700>**监听端口**</span>：<span style=color:#e6db74>`Server`</span> 使用 <span style=color:#e6db74>`net.Listen`</span> 在指定地址上创建了一个网络监听器（Listener）。
</span></span><span style=display:flex><span><span style=color:#66d9ef>3.</span> <span style=font-weight:700>**循环Accept**</span>：在一个 <span style=color:#e6db74>`for`</span> 循环中，不停地调用 <span style=color:#e6db74>`Listener.Accept()`</span> 接受新连接。
</span></span><span style=display:flex><span><span style=color:#66d9ef>4.</span> <span style=font-weight:700>**创建 goroutine**</span>：每接受一个连接，就**启动一个新的 goroutine**（轻量级线程）来处理这个连接。这是Go语言高并发的基石。
</span></span><span style=display:flex><span><span style=color:#66d9ef>5.</span> <span style=font-weight:700>**处理连接**</span>：在新的 goroutine 中，循环读取连接上的多个请求（如果开启了Keep-Alive）。
</span></span><span style=display:flex><span><span style=color:#66d9ef>6.</span> <span style=font-weight:700>**寻找 Handler**</span>：对于每个请求，调用 <span style=color:#e6db74>`serverHandler{c.server}.ServeHTTP(w, w.req)`</span>。<span style=color:#e6db74>`serverHandler`</span> 是一个内部包装，它的 <span style=color:#e6db74>`ServeHTTP`</span> 方法会检查 <span style=color:#e6db74>`Server`</span> 结构体中是否设置了 <span style=color:#e6db74>`Handler`</span>（即我们传入的自定义路由），如果没有，就使用 <span style=color:#e6db74>`DefaultServeMux`</span>。
</span></span><span style=display:flex><span><span style=color:#66d9ef>7.</span> <span style=font-weight:700>**路由分发**</span>：调用 <span style=color:#e6db74>`Handler`</span>（也就是 <span style=color:#e6db74>`ServeMux`</span>）的 <span style=color:#e6db74>`ServeHTTP`</span> 方法。<span style=color:#e6db74>`ServeMux`</span> 根据请求的路径，查找之前注册的路由表，找到最匹配的用户自定义 <span style=color:#e6db74>`Handler`</span>（可能是 <span style=color:#e6db74>`HandlerFunc`</span> 或任何实现了 <span style=color:#e6db74>`Handler`</span> 接口的对象）。
</span></span><span style=display:flex><span><span style=color:#66d9ef>8.</span> <span style=font-weight:700>**执行业务逻辑**</span>：最后，调用找到的 <span style=color:#e6db74>`Handler`</span> 的 <span style=color:#e6db74>`ServeHTTP`</span> 方法，也就是执行我们写的业务代码。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>这个过程清晰地展示了 <span style=color:#e6db74>`net/http`</span> 的设计精髓：通过 <span style=color:#e6db74>`Handler`</span> 接口实现了高度的可扩展性，通过 <span style=color:#e6db74>`ServeMux`</span> 提供了基础的路由能力，并通过 goroutine-per-connection 模型保障了高并发性能。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### 3. 功能强大的HTTP客户端
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>`net/http`</span> 不仅服务端强大，其客户端功能也同样完善。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 3.1 基础请求：`Get`、`Post`
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>发起简单的HTTP请求非常直接。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;io/ioutil&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;https://api.github.com/users/octocat&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// !!! 重要：必须关闭响应体，以防止资源泄露 !!!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;状态码: %d\n&#34;</span>, <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>StatusCode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;响应头: %v\n&#34;</span>, <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Header</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;响应体: %s\n&#34;</span>, string(<span style=color:#a6e22e>body</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>类似地，还有 <span style=color:#e6db74>`http.Post`</span> 和 <span style=color:#e6db74>`http.PostForm`</span> 可用。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 3.2 高级控制：`http.Client`
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>对于生产级应用，直接使用 <span style=color:#e6db74>`http.Get`</span> 是不够的，因为它使用默认的 <span style=color:#e6db74>`http.DefaultClient`</span>，缺乏超时等关键控制。此时需要自定义 <span style=color:#e6db74>`http.Client`</span>。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置超时时间，避免请求卡死</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 自定义重定向策略</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CheckRedirect</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>, <span style=color:#a6e22e>via</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;重定向到:&#34;</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// 允许最多10次重定向</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>resp</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;http://example.com&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 3.3 核心驱动：`http.Transport`
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>`http.Client`</span> 是外观，真正的执行者是 <span style=color:#e6db74>`http.Transport`</span>。它负责管理连接池、TLS配置、代理等底层细节。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 自定义 Transport，优化连接池</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>tr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Transport</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MaxIdleConns</span>: <span style=color:#ae81ff>100</span>, <span style=color:#75715e>// 最大空闲连接数</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MaxIdleConnsPerHost</span>: <span style=color:#ae81ff>10</span>, <span style=color:#75715e>// 每个Host的最大空闲连接数</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IdleConnTimeout</span>: <span style=color:#ae81ff>90</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#75715e>// 空闲连接超时时间</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TLSClientConfig</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tls</span>.<span style=color:#a6e22e>Config</span>{<span style=color:#a6e22e>InsecureSkipVerify</span>: <span style=color:#66d9ef>true</span>}, <span style=color:#75715e>// 跳过证书验证（仅示例，请勿用于生产）</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Transport</span>: <span style=color:#a6e22e>tr</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>合理配置 <span style=color:#e6db74>`Transport`</span> 可以大幅提升客户端在高并发场景下的性能。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### 4. 最佳实践与进阶技巧
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 4.1 优雅处理请求
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **务必关闭 Body**：无论是服务端读取请求体，还是客户端读取响应体，都要确保在最后关闭 <span style=color:#e6db74>`Body`</span>，否则会造成连接泄露。
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **使用 Context 超时控制**：对于可能耗时较长的请求，可以使用 <span style=color:#e6db74>`context.WithTimeout`</span> 创建一个带超时的 Context，并传递给 <span style=color:#e6db74>`http.NewRequestWithContext`</span>。当超时发生时，请求会自动取消。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 4.2 构建健壮的服务端
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **自定义 Server**：除了 <span style=color:#e6db74>`ListenAndServe`</span>，更推荐显式创建 <span style=color:#e6db74>`http.Server`</span> 对象，以便精细化配置，如读写超时、最大Header大小等，防止慢攻击。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>srv</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Server</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Addr</span>: <span style=color:#e6db74>&#34;:8080&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>myHandler</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ReadTimeout</span>: <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WriteTimeout</span>: <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>ListenAndServe</span>())
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>*</span> **中间件模式**：<span style=color:#e6db74>`net/http`</span> 虽然没有内置中间件，但通过函数式编程可以轻松实现。一个中间件就是一个接收 <span style=color:#e6db74>`Handler`</span> 并返回一个新 <span style=color:#e6db74>`Handler`</span> 的函数。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>```go
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loggingMiddleware</span>(<span style=color:#a6e22e>next</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;收到请求: %s %s&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>) <span style=color:#75715e>// 调用下一个处理器</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;请求处理完毕&#34;</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>finalHandler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>final</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>loggingMiddleware</span>(<span style=color:#a6e22e>finalHandler</span>))
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#### 4.3 何时使用第三方框架？
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>`net/http`</span> 功能强大，但对于非常复杂的路由需求（如路径参数 <span style=color:#e6db74>`/users/:id`</span>）、需要大量开箱即用的中间件（如JWT认证、限流）或更强大的依赖注入等场景，引入像 <span style=color:#e6db74>`gin`</span>、<span style=color:#e6db74>`echo`</span> 或 <span style=color:#e6db74>`gorilla/mux`</span> 等第三方框架可以显著提升开发效率。它们的底层，无一例外，都是建立在 <span style=color:#e6db74>`net/http`</span> 之上的。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>希望这份详解能帮助你更好地理解和使用Go标准库中的这颗明珠。
</span></span></code></pre></div></div><footer class=article-footer><ul class=article-category-list><li class=article-tag-list-item data-aos=zoom-in><a class=article-category-link href=/categories/go data-aos=zoom-in>Go</a></li></ul><ul class=article-tag-list itemprop=keywords><li class=article-tag-list-item data-aos=zoom-in><a class=article-tag-list-link href=/tags/go rel=tag>Go</a></li></ul></footer></div><nav id=article-nav aria-label="Article navigation" data-aos=fade-up><div class="article-nav-link-wrap left"><img data-src=/post/gocache/gocache.jpg data-sizes=auto alt="GoCache 学习建议" class=lazyload><a href=/post/gocache/ aria-label="前一篇:GoCache 学习建议" title="前一篇:GoCache 学习建议"></a><div class=article-nav-caption>前一篇</div><h3 class=article-nav-title>GoCache 学习建议</h3></div></nav></article></section></div><footer id=footer aria-label="Site footer"><div style=width:100%;overflow:hidden><div class=footer-line></div></div><div id=footer-info><div><span class=icon-copyright></span>2026<span class="footer-info-sep rotate"></span>Elari39</div></div></footer><div class=sidebar-top><div class="sidebar-top-taichi rotate"></div><div class=arrow-up></div></div><div id=mask class=hide></div></div><nav id=mobile-nav aria-label="Mobile navigation"><div class=sidebar-wrap><div class=sidebar-toc-sidebar><h3 class=toc-title>文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents></nav></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Elari39 class=lazyload><div class=sidebar-author-name>Elari39</div><div class=sidebar-description>请别在意。
我是旅人，得继续旅行才行…</div></div><div class=sidebar-state><div class=sidebar-state-article><div>文章</div><div class=sidebar-state-number>2</div></div><a class=sidebar-state-category href=/categories/ aria-label=sidebar-state-category-link><div>分类</div><div class=sidebar-state-number>1</div></a><a class=sidebar-state-tag href=/tags/ aria-label=sidebar-state-tag-link><div>标签</div><div class=sidebar-state-number>1</div></a></div><div class=sidebar-social><div class="icon-email sidebar-social-icon"><a href=mailto:majo_elaina@qq.com itemprop=url target=_blank aria-label=email rel="noopener nofollow noreferrer"></a></div><div class="icon-github sidebar-social-icon"><a href=https://github.com/Elari39 itemprop=url target=_blank aria-label=github rel="noopener nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=首页></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>首页</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=归档></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>归档</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=关于></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>关于</div></div></div></div></div><div class=sidebar-btn-wrapper><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></nav></div><script src=https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js integrity=sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf+e crossorigin=anonymous></script><script src=https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js integrity=sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q crossorigin=anonymous></script><script src=/js/main.js integrity crossorigin=anonymous></script><script src=/js/aos.js integrity crossorigin=anonymous></script><script>var aosInit=()=>{AOS.init({duration:1e3,easing:"ease",once:!0,offset:50})};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",aosInit):aosInit()</script><script src=/js/pjax_main.js integrity crossorigin=anonymous data-pjax></script><script>var setupFirework=()=>{if((!!1||!window.matchMedia("(max-width: 768px)").matches)&&window.firework){const e=JSON.parse('{"excludeelements":["a","button"],"particles":[{"colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["emit"],"number":20,"shape":"circle","shapeOptions":{"alpha":[0.3,0.5],"radius":[16,32]}},{"colors":["var(--red-0)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["diffuse"],"number":1,"shape":"circle","shapeOptions":{"alpha":[0.2,0.5],"lineWidth":6,"radius":20}}]}');e.excludeElements=e.excludeelements,delete e.excludeelements,window.firework(e)}}</script><script src=https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js defer onload=setupFirework() integrity=sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8+pUoWX8n1rgq282T crossorigin=anonymous></script><div id=lazy-script><div><script data-pjax>window.REIMU_POST={author:"Elari39",title:"GoHttp库",url:"https://Elari39.github.io/post/gohttp/gohttpv1/",description:"Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。",cover:"https://Elari39.github.io/images/elaina-backfront1-1.jpeg"}</script><script src=/js/insert_highlight.js integrity crossorigin=anonymous data-pjax></script><script src=/js/tabs.js integrity crossorigin=anonymous data-pjax defer></script><script type=module data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
        }
        pswp()
      </script></div></div><script>"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()})</script><script>const reimuCopyright=String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;console.log(String.raw`%c ${reimuCopyright}`,"color: #ff5252;"),console.log("%c Theme.Reimu %c https://github.com/D-Sketon/hugo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script></body></html>