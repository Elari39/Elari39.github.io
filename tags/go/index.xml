<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Elari的博客</title><link>https://Elari39.github.io/tags/go/</link><description>Recent content from Elari的博客</description><generator>Hugo</generator><language>zh-cn</language><managingEditor>majo_elaina@qq.com (Elari39)</managingEditor><webMaster>majo_elaina@qq.com (Elari39)</webMaster><copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright><lastBuildDate>Fri, 20 Feb 2026 13:00:00 +0800</lastBuildDate><atom:link href="https://Elari39.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Day 02: 数组 - 双指针、滑动窗口与模拟</title><link>https://Elari39.github.io/post/algorithm/day02/</link><pubDate>Fri, 20 Feb 2026 13:00:00 +0800</pubDate><author>majo_elaina@qq.com (Elari39)</author><guid>https://Elari39.github.io/post/algorithm/day02/</guid><description>
<![CDATA[<h1>Day 02: 数组 - 双指针、滑动窗口与模拟</h1><p>作者：Elari39（majo_elaina@qq.com）</p>
        
          <h1 id="数组---双指针滑动窗口与模拟">
<a class="header-anchor" href="#%e6%95%b0%e7%bb%84---%e5%8f%8c%e6%8c%87%e9%92%88%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e4%b8%8e%e6%a8%a1%e6%8b%9f"></a>
数组 - 双指针、滑动窗口与模拟
</h1><p>今天是<strong>代码随想录</strong>数组专题第二天！昨天打好了理论基础，今天我们重点学习数组中极具代表性的三大高频技巧：<strong>双指针法</strong>（处理有序数组）、<strong>滑动窗口</strong>（用于求最小长度连续子数组）和<strong>边界模拟</strong>（生成螺旋矩阵）。掌握这些套路后，处理区间、矩阵类问题将事半功倍。</p>
<p>我们继续用 <strong>Go 语言</strong> 手撕以下三道经典题目，每道题都会附上<strong>完整可运行代码 + 逐行详细解析</strong>，帮助你彻底吃透实现细节。</p>
<h2 id="题目列表">
<a class="header-anchor" href="#%e9%a2%98%e7%9b%ae%e5%88%97%e8%a1%a8"></a>
题目列表
</h2><ul>
<li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></li>
<li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></li>
<li><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></li>
</ul>
<hr>
<h2 id="977-有序数组的平方">
<a class="header-anchor" href="#977-%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e5%b9%b3%e6%96%b9"></a>
977. 有序数组的平方
</h2><p><strong>题目描述</strong>：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<p><strong>Go 代码实现</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">sortedSquares</span><span class="p">(</span><span class="nx">nums</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="c1">// 结果数组</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">--</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">])</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">left</span><span class="o">++</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">right</span><span class="o">--</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">res</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="c1">// 辅助函数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="nx">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>详细解析</strong>（逐行讲解）：</p>
        
        <hr><p>本文2026-02-20首发于<a href='https://Elari39.github.io/'>Elari的博客</a>，最后修改于2026-02-20</p>]]></description><category>代码随想录</category></item><item><title>Day 01: 数组理论基础</title><link>https://Elari39.github.io/post/algorithm/day01/</link><pubDate>Thu, 19 Feb 2026 13:00:00 +0800</pubDate><author>majo_elaina@qq.com (Elari39)</author><guid>https://Elari39.github.io/post/algorithm/day01/</guid><description>
<![CDATA[<h1>Day 01: 数组理论基础</h1><p>作者：Elari39（majo_elaina@qq.com）</p>
        
          <h1 id="数组理论基础">
<a class="header-anchor" href="#%e6%95%b0%e7%bb%84%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80"></a>
数组理论基础
</h1><p>今天正式开启<strong>代码随想录</strong>的学习之旅！作为第一天，我们重点复习数组的基础知识和常用技巧。数组在 Go 中以切片（slice）形式存在，掌握好切片的底层操作、双指针、二分查找等，是后续所有算法题的基石。</p>
<p>今天我们一起用 <strong>Go 语言</strong> 手撕以下三道经典数组题目，每道题都会附上<strong>完整可运行代码 + 逐行详细解析</strong>，帮助你彻底吃透实现细节。</p>
<h2 id="题目列表">
<a class="header-anchor" href="#%e9%a2%98%e7%9b%ae%e5%88%97%e8%a1%a8"></a>
题目列表
</h2><ul>
<li><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></li>
<li><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></li>
<li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></li>
</ul>
<hr>
<h2 id="704-二分查找">
<a class="header-anchor" href="#704-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be"></a>
704. 二分查找
</h2><p><strong>题目描述</strong>：给定一个升序排列的整数数组 <code>nums</code> 和一个目标值 <code>target</code>，在数组中搜索 <code>target</code>，如果存在返回下标，否则返回 <code>-1</code>。要求时间复杂度 <code>O(log n)</code>。</p>
<p><strong>Go 代码实现</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="nx">nums</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 防止溢出（Go int 虽然不会像 C++ 那样轻易溢出，但这是好习惯）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">mid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">mid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>详细解析</strong>（逐行讲解）：</p>
        
        <hr><p>本文2026-02-19首发于<a href='https://Elari39.github.io/'>Elari的博客</a>，最后修改于2026-02-19</p>]]></description><category>代码随想录</category></item><item><title>GoHttp库</title><link>https://Elari39.github.io/post/gohttpv1/</link><pubDate>Tue, 17 Feb 2026 19:41:00 +0800</pubDate><author>majo_elaina@qq.com (Elari39)</author><guid>https://Elari39.github.io/post/gohttpv1/</guid><description>
<![CDATA[<h1>GoHttp库</h1><p>作者：Elari39（majo_elaina@qq.com）</p>
        
          Go 语言的 net/http 标准库是构建 HTTP 服务端和客户端的基石，它设计简洁、功能强大，并且是众多第三方 Web 框架（如 Gin、Echo）的底层依赖。无论你是想从零搭建一个高性能的 Web 服务，还是希望在使用框架时能深入理解其原理，掌握 net/http 都是必修课。本文将从零开始，以最新版本的 Go（语法层面无破坏性变更）为例，详细拆解 net/http 的核心概念、工作机制以及最佳实践。
        
        <hr><p>本文2026-02-17首发于<a href='https://Elari39.github.io/'>Elari的博客</a>，最后修改于2026-02-17</p>]]></description><category>Go</category></item><item><title>GoCache 学习建议</title><link>https://Elari39.github.io/post/gocache/</link><pubDate>Sat, 14 Feb 2026 21:57:00 +0800</pubDate><author>majo_elaina@qq.com (Elari39)</author><guid>https://Elari39.github.io/post/gocache/</guid><description>
<![CDATA[<h1>GoCache 学习建议</h1><p>作者：Elari39（majo_elaina@qq.com）</p>
        
          <h1 id="学习建议">
<a class="header-anchor" href="#%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae"></a>
学习建议
</h1><p><strong>完成项目指导时间</strong></p>
<ul>
<li>如果具备【基础要求】里的基础，每天 6 小时，约 7 天完成。</li>
<li>如果边学边做，每天 6~8 小时，约 15 天完成。</li>
</ul>
<p><strong>代码量</strong><br>
2000 行左右（除去测试代码）</p>
<hr>
<h2 id="基础要求">
<a class="header-anchor" href="#%e5%9f%ba%e7%a1%80%e8%a6%81%e6%b1%82"></a>
基础要求
</h2><ul>
<li><strong>Go 语言基础</strong>：goroutine、channel、接口等核心概念</li>
<li><strong>缓存原理</strong>：缓存淘汰策略（LRU、LFU 等）</li>
<li><strong>网络编程</strong>：gRPC 基础、HTTP 协议、TCP/IP</li>
</ul>
<hr>
<h2 id="循序渐进的学习顺序">
<a class="header-anchor" href="#%e5%be%aa%e5%ba%8f%e6%b8%90%e8%bf%9b%e7%9a%84%e5%ad%a6%e4%b9%a0%e9%a1%ba%e5%ba%8f"></a>
循序渐进的学习顺序
</h2><ol>
<li>
<p><strong>从单机缓存开始</strong></p>
<ul>
<li>先理解 <code>ByteView</code>、<code>lruCache</code> 等核心数据结构</li>
<li>熟悉 <code>Cache</code> 和基本的缓存操作</li>
</ul>
</li>
<li>
<p><strong>理解分组缓存</strong></p>
<ul>
<li>学习 <code>Group</code> 结构及其工作原理</li>
<li>掌握缓存加载、过期策略等机制</li>
</ul>
</li>
<li>
<p><strong>研究分布式扩展</strong></p>
<ul>
<li>一致性哈希算法实现</li>
<li>节点间通信协议</li>
<li>服务注册与发现</li>
</ul>
</li>
<li>
<p><strong>深入高级特性</strong></p>
<ul>
<li>缓存击穿防护</li>
<li>分段锁与高并发优化</li>
<li>优雅关闭与资源管理</li>
</ul>
</li>
</ol>
<hr>
<h2 id="代码阅读方式">
<a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e9%98%85%e8%af%bb%e6%96%b9%e5%bc%8f"></a>
代码阅读方式
</h2><ol>
<li>
<p><strong>绘制组件关系图</strong></p>
<ul>
<li>梳理核心接口和实现类</li>
<li>理清组件间的调用关系</li>
</ul>
</li>
<li>
<p><strong>断点调试关键流程</strong></p>
<ul>
<li><code>Set/Get</code> 操作的完整链路</li>
<li>分布式场景下的数据同步</li>
</ul>
</li>
<li>
<p><strong>编写单元测试</strong></p>
<ul>
<li>为关键组件编写测试用例</li>
<li>使用基准测试验证性能优化</li>
</ul>
</li>
<li>
<p><strong>模拟故障场景</strong></p>
<ul>
<li>节点宕机时的系统行为</li>
<li>网络分区下的一致性保证</li>
</ul>
</li>
</ol>
<hr>
<h2 id="什么是缓存">
<a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98"></a>
什么是缓存
</h2><p>缓存是将高频访问的数据暂存到内存中，是加速数据访问的存储，降低延迟，提高吞吐率的利器。</p>
<h2 id="为什么要实现缓存系统">
<a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9e%e7%8e%b0%e7%bc%93%e5%ad%98%e7%b3%bb%e7%bb%9f"></a>
为什么要实现缓存系统
</h2><p>因缓存的使用相关需求，通过牺牲一部分服务器内存，减少对磁盘或者数据库资源进行直接读写，可换取更快响应速度，尤其是处理高并发的场景，负责存储经常访问的数据，通过设计合理的缓存机制提高资源的访问效率。由于服务器的内存是有限的，我们不能把所有数据都存放在内存中，因此需要一种机制来决定当使用内存超过一定标准时，应该删除哪些数据，这就涉及到缓存淘汰策略的选择。</p>
        
        <hr><p>本文2026-02-14首发于<a href='https://Elari39.github.io/'>Elari的博客</a>，最后修改于2026-02-14</p>]]></description><category>Go</category></item></channel></rss>